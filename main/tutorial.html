<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorials &mdash; stdpopsim 0.1.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Command-line options" href="cli_arguments.html" />
    <link rel="prev" title="Catalog" href="catalog.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> stdpopsim
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="catalog.html">Catalog</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#running-stdpopsim-with-the-command-line-interface-cli">Running <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> with the command-line interface (CLI)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-first-simulation">A first simulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#choose-a-species-and-a-contig">Choose a species and a contig</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choose-a-model-and-a-sampling-scheme">Choose a model and a sampling scheme</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convert-output-to-vcf">Convert output to VCF</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-slim-simulation-engine">Using the SLiM simulation engine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#specifying-the-engine">Specifying the engine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-scaling-factor">The scaling factor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-output-from-slim">Debugging output from SLiM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#choose-a-species-drosophila-melanogaster">Choose a species: Drosophila melanogaster</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#running-stdpopsim-with-the-python-interface-api">Running stdpopsim with the Python interface (API)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#running-a-published-model">Running a published model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pick-a-species-and-demographic-model">Pick a species and demographic model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-up-the-contig">Set up the contig</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choose-a-sampling-scheme-and-simulate">Choose a sampling scheme and simulate</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#running-a-generic-model">Running a generic model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#choose-a-species">Choose a species</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-up-the-generic-model">Set up the generic model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choose-a-contig-and-recombination-map">Choose a contig and recombination map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">Choose a sampling scheme, and simulate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sanity-check-the-tree-sequence-output">Sanity check the tree sequence output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-to-vcf">Output to VCF</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-slim-engine">Using the SLiM engine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#an-example-simulation">An example simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-slim-options">Other SLiM options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#incorporating-selection">Incorporating selection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simulating-with-a-genome-wide-dfe">1. Simulating with a genome-wide DFE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simulating-selection-in-a-single-gene">2. Simulating selection in a single gene</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simulating-selection-on-exons">3. Simulating selection on exons</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sec-tute-selective-sweep">4.  Selective sweep</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-analyses-with-stdpopsim">Example analyses with <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#calculating-genetic-divergence">Calculating genetic divergence</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simulating-the-dataset">1. Simulating the dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calculating-divergences">2. Calculating divergences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plotting-the-divergences">3. Plotting the divergences</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#calculating-the-allele-frequency-spectrum">Calculating the allele frequency spectrum</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">1. Simulating the dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calculating-the-afs">2. Calculating the AFS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plotting-the-afs">3. Plotting the AFS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cli_arguments.html">Command-line options</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelogs.html">Changelogs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">stdpopsim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Tutorials</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorials">
<span id="sec-tutorial"></span><h1>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this headline"></a></h1>
<p>There are two main ways of accessing the resources of the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> package
that will be detailed in this tutorial. The first is via the command line
interface (CLI). This is useful if you want to do a straightforward run of the
models in the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">catalog</span></a>. The other way to
access the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> resources is via the python API. This is a bit more
complicated, but allows for more advanced tasks. This tutorial will walk
through both ways of using the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> package as well as a few examples
of producing and processing output.</p>
<p>To simulate genomes using <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code>,
we need to make several choices about what will be simulated:</p>
<ol class="arabic simple">
<li><p>which species</p></li>
<li><p>which contig (i.e., how much of what chromosome)</p></li>
<li><p>which genetic map</p></li>
<li><p>which demographic model</p></li>
<li><p>how many samples from each population of the model</p></li>
<li><p>which simulation engine to use</p></li>
</ol>
<p>These choices are nested:
the species determines what contigs, genetic maps, and demographic models are available,
and the demographic model determines how many populations can be sampled from.
Currently, the two choices of simulation engine are <code class="docutils literal notranslate"><span class="pre">msprime</span></code> and <code class="docutils literal notranslate"><span class="pre">SLiM</span></code>.
Below are examples of making these choices in various contexts,
using both CLI and python interfaces.</p>
<section id="running-stdpopsim-with-the-command-line-interface-cli">
<span id="sec-cli-tute"></span><h2>Running <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> with the command-line interface (CLI)<a class="headerlink" href="#running-stdpopsim-with-the-command-line-interface-cli" title="Permalink to this headline"></a></h2>
<p>In order to use the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> CLI the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> package must be
installed (see <a class="reference internal" href="installation.html#sec-installation"><span class="std std-ref">Installation</span></a>). The CLI provides access
to the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">catalog</span></a> of models that have already been implemented
by <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code>.</p>
<section id="a-first-simulation">
<h3>A first simulation<a class="headerlink" href="#a-first-simulation" title="Permalink to this headline"></a></h3>
<p>As a first step, we’ll use the CLI built-in help
to build up to a realistic coalescent simulation of some copies of
human chromosome 22 with the HapMap genetic map,
and a published demographic model.</p>
<section id="choose-a-species-and-a-contig">
<h4>Choose a species and a contig<a class="headerlink" href="#choose-a-species-and-a-contig" title="Permalink to this headline"></a></h4>
<p>The first step for using the CLI is to select the species that
you are interested in simulating data for. In order to see which species are
available run</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ stdpopsim --help
usage: stdpopsim [-h] [-V] [-v | -q] [-c CACHE_DIR] [-e {msprime,slim}]
                 [--msprime-model {hudson,dtwf,smc,smc_prime}]
                 [--msprime-change-model T MODEL] [--slim-path PATH]
                 [--slim-script] [--slim-scaling-factor Q] [--slim-burn-in X]
                 {AnoCar,HelMel,AnoGam,EscCol,StrAga,ApiMel,AnaPla,DroMel,DroSec,BosTau,AedAeg,PonAbe,CaeEle,HomSap,CanFam,ChlRei,AraTha,download-genetic-maps}
                 ...

Command line interface for stdpopsim.

positional arguments:
  {AnoCar,HelMel,AnoGam,EscCol,StrAga,ApiMel,AnaPla,DroMel,DroSec,BosTau,AedAeg,PonAbe,CaeEle,HomSap,CanFam,ChlRei,AraTha,download-genetic-maps}
    AnoCar              Run simulations for Anolis carolinensis.
    HelMel              Run simulations for Heliconius melpomene.
    AnoGam              Run simulations for Anopheles gambiae.
    EscCol              Run simulations for Escherichia coli.
    StrAga              Run simulations for Streptococcus agalactiae.
    ApiMel              Run simulations for Apis mellifera.
    AnaPla              Run simulations for Anas platyrhynchos.
    DroMel              Run simulations for Drosophila melanogaster.
    DroSec              Run simulations for Drosophila sechellia.
    BosTau              Run simulations for Bos taurus.
    AedAeg              Run simulations for Aedes aegypti.
    PonAbe              Run simulations for Pongo abelii.
    CaeEle              Run simulations for Caenorhabditis elegans.
    HomSap              Run simulations for Homo sapiens.
    CanFam              Run simulations for Canis familiaris.
    ChlRei              Run simulations for Chlamydomonas reinhardtii.
    AraTha              Run simulations for Arabidopsis thaliana.
    download-genetic-maps
                        Download genetic maps

optional arguments:
  -h, --help            show this help message and exit
  -V, --version         show program&#39;s version number and exit
  -v, --verbose         Increase logging verbosity (can use be used multiple
                        times).
  -q, --quiet           Do not write any non-essential messages
  -c CACHE_DIR, --cache-dir CACHE_DIR
                        Set the cache directory to the specified value. Note
                        that this can also be set using the environment
                        variable STDPOPSIM_CACHE. If both the environment
                        variable and this option are set, the option takes
                        precedence. Default: /home/runner/.cache/stdpopsim
  -e {msprime,slim}, --engine {msprime,slim}
                        Specify a simulation engine.

msprime specific parameters:
  --msprime-model {hudson,dtwf,smc,smc_prime}
                        Specify the simulation model used by msprime. See
                        msprime API documentation for details.
  --msprime-change-model T MODEL
                        Change to the specified simulation MODEL at generation
                        T. This option may provided multiple times.

SLiM specific parameters:
  --slim-path PATH      Full path to `slim&#39; executable.
  --slim-script         Write script to stdout and exit without running SLiM.
  --slim-scaling-factor Q
                        Rescale model parameters by Q to speed up simulation.
                        See SLiM manual: `5.5 Rescaling population sizes to
                        improve simulation performance`. [default=1].
  --slim-burn-in X      Length of the burn-in phase, in units of N generations
                        [default=10].
</pre></div>
</div>
<p>This shows the species currently supported by <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code>. This means that
<code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> knows various traits of these species including chromosome size
and recombination rates. Once we’ve selected a species, in this case humans, we
can look at the help again as follows.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ stdpopsim HomSap --help
usage: stdpopsim HomSap [-h] [--help-models [HELP_MODELS]] [-b BIBTEX_FILE]
                        [--help-genetic-maps [HELP_GENETIC_MAPS]] [-D] [-g]
                        [-c] [-L LENGTH] [-i INCLUSION_MASK]
                        [-e EXCLUSION_MASK] [-l LENGTH_MULTIPLIER] [-s SEED]
                        [-d] [-o OUTPUT]
                        samples [samples ...]

Run simulations for Homo sapiens using up-to-date genome information,
genetic maps and simulation models from the literature. NOTE: By
default, the tskit &#39;.trees&#39; binary file is written to stdout,so you
should either redirect this to a file or use the &#39;--output&#39; option to
specify a filename.

Default population parameters for Homo sapiens:
Generation time: 30
Population size: 10000
Mutation rate: 1.29e-08
Recombination rate: 1.205e-08

positional arguments:
...
</pre></div>
</div>
<p>For conciseness we do not show all the output here but this time you should see a
different output which shows options for performing the simulation itself and
the species default parameters. This includes selecting the demographic model,
chromosome, recombination map, and number of samples.</p>
<p>The most basic simulation we can run is to simulate two (haploid) genomes
- i.e., two samples -
using the species’ defaults as seen in the species help (<code class="docutils literal notranslate"><span class="pre">stdpopsim</span> <span class="pre">HomSap</span> <span class="pre">--help</span></code>).
These defaults include constant size population, a uniform recombination map based
on the average recombination rate (either genome-wide or within a chromosome, if
specified), and the mutation rate shown above.
To save time we will specify that the simulation use
chromosome 22, using the <code class="docutils literal notranslate"><span class="pre">-c</span></code> option. We also specify that the resulting
tree-sequence formatted output should be written to the file <code class="docutils literal notranslate"><span class="pre">foo.ts</span></code> with the
<code class="docutils literal notranslate"><span class="pre">-o</span></code> option. For more information on how to use tree-sequence files see
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/introduction.html">tskit</a>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim HomSap -c chr22 -o foo.ts <span class="m">2</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It’s important to remember to either redirect the output of <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code>
to file or to use the <code class="docutils literal notranslate"><span class="pre">-o/--output</span></code> option. If you do not, the
binary output may mess up your terminal session.</p>
</div>
</section>
<section id="choose-a-model-and-a-sampling-scheme">
<h4>Choose a model and a sampling scheme<a class="headerlink" href="#choose-a-model-and-a-sampling-scheme" title="Permalink to this headline"></a></h4>
<p>Next, suppose we want to use a specific demographic model. We look up the available models
using the <code class="docutils literal notranslate"><span class="pre">--help-models</span></code> flag (here, truncated for space):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ stdpopsim HomSap --help-models

All simulation models for Homo sapiens

OutOfAfricaExtendedNeandertalAdmixturePulse_3I21: Three population out-of-Africa with an extended pulse of         Neandertal admixture into Europeans
     Demographic model af an extended admixture pulse from Neandertals
    into Europenas taken from Iasi et al. (2021). This model simulates
    3 populations: Africans, Europeans and Neandertals with an Out-of-
    Africa event. The population sizes are constant with an
    unidirectional admixture from Neandertals into Europeans after the
    split between Europeans and Africans. The admixture event is
    modelled as an 800 generation (20 ky) long extended admixture
    pulse.

    Populations:
        0: 1000 Genomes YRI (Yorubans)
        1: 1000 Genomes CEU (Utah Residents             (CEPH) with Northern and Western European Ancestry
        2: Neandertals

OutOfAfrica_3G09: Three population out-of-Africa
     The three population Out-of-Africa model from Gutenkunst et al.
    2009. It describes the ancestral human population in Africa, the
    out of Africa event, and the subsequent European-Asian population
    split. Model parameters are the maximum likelihood values of the
    various parameters given in Table 1 of Gutenkunst et al.

    Populations:
        0: 1000 Genomes YRI (Yoruba)
        1: 1000 Genomes CEU (Utah Residents (CEPH) with Northern and Western European Ancestry
        2: 1000 Genomes CHB (Han Chinese in Beijing, China)

...
</pre></div>
</div>
<p>This gives all of the possible demographic models we could simulate. We choose
the two population out-of-Africa <a class="reference internal" href="catalog.html#sec_catalog_homsap_models_outofafrica_2t12"><span class="std std-ref">model</span></a>
from <a class="reference external" href="https://doi.org/10.1126/science.1219240">Tennesen et al. (2012)</a> .
By looking at the model help we find that the name for this model is
<code class="docutils literal notranslate"><span class="pre">OutOfAfrica_2T12</span></code> and that we can specify it using
the <code class="docutils literal notranslate"><span class="pre">--demographic-model</span></code> or <code class="docutils literal notranslate"><span class="pre">-d</span></code> option. We choose to draw two samples from the
“African American” population and three samples from the “European American” population.
To increase simulation speed we can also choose to simulate a sequence that is
a fraction of the length of the specified chromosome using the <code class="docutils literal notranslate"><span class="pre">-l</span></code> option
(e.g. 5%). This is just specifying a sequence length, not actually selecting
a subset of the chromosome to sequence and as such cannot be used with anything
other than a uniform recombination map. The command now looks like this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim HomSap -c chr22 -l <span class="m">0</span>.05 -o foo.ts -d OutOfAfrica_2T12 <span class="m">2</span> <span class="m">3</span>
</pre></div>
</div>
<p>Note that the number of samples from each population are simply specified
as two numbers at the end of the command. There must be <em>two</em> numbers because the
model has two populations that we can sample from
The order of those numbers is the same as the order
specified in the model documentation. In this case, <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">3</span></code> means
we are simulating two African American samples and three European American samples.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Many demographic models were inferred or calibrated using a mutation rate that
differs from the cataloged species’ mutation rate. Simulations using the CLI now
automatically use the <em>model’s</em> specified mutation rate instead of the species
rate, so that expected levels of diversity more closely match those observed in
the data that were used to infer the demographic model. For generic demographic
models or those without associated mutation rates, the species mutation rate is
used.</p>
</div>
<p>Now we want to add an empirical recombination map to make the simulation more
realistic. We can look up the available recombination maps using the
<code class="docutils literal notranslate"><span class="pre">--help-genetic-maps</span></code> flag (here, truncated for space):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ stdpopsim HomSap --help-genetic-maps

All genetic maps for Homo sapiens

HapMapII_GRCh37
     This genetic map is from the Phase II Hapmap project and based on
    3.1 million genotyped SNPs from 270 individuals across four
    populations (YRI, CEU, CHB and JPT). Genome wide recombination
    rates were estimated using LDHat. This version of the HapMap
    genetic map was lifted over to GRCh37 (and adjusted in regions
    where the genome assembly had rearranged) for use in the 1000
    Genomes project. Please see the README file on the 1000 Genomes
    download site for details of these adjustments. ftp://ftp-trace.nc
    bi.nih.gov/1000genomes/ftp/technical/working/20110106_recombinatio
    n_hotspots

...
</pre></div>
</div>
<p>In this case we choose the
<a class="reference internal" href="catalog.html#sec_catalog_homsap_genetic_maps_hapmapii_grch37"><span class="std std-ref">HapMapII_GRCh37</span></a> map. Empirical
recombination maps cannot be used with length multipliers so we have to remove
the <code class="docutils literal notranslate"><span class="pre">-l</span></code> option. (NOTE: this may a minute or so to run).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim HomSap -g HapMapII_GRCh37 -c chr22 -o foo.ts -d OutOfAfrica_2T12 <span class="m">2</span> <span class="m">3</span>
</pre></div>
</div>
<p>For reproducibility we can also choose set the seed for the simulator using the
<code class="docutils literal notranslate"><span class="pre">-s</span></code> flag.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim HomSap -s <span class="m">1046</span> -g HapMapII_GRCh37 -c chr22 -o foo.ts -d OutOfAfrica_2T12 <span class="m">2</span> <span class="m">3</span>
</pre></div>
</div>
<p>On running these commands, the CLI also outputs the relevant citations for both
the simulator used and the resources used for simulation scenario.</p>
</section>
<section id="convert-output-to-vcf">
<span id="sec-cli-vcf-output"></span><h4>Convert output to VCF<a class="headerlink" href="#convert-output-to-vcf" title="Permalink to this headline"></a></h4>
<p>The output from a <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> simulation is a <em>tree sequence</em>,
a compact and efficient format for storing both genealogies and genome sequence.
Some examples of analyzing tree sequences are given
<a class="reference internal" href="#sec-tute-analyses"><span class="std std-ref">below</span></a>.
If desired, these can be converted to VCF on the command line if the
<a class="reference external" href="https://tskit.dev/tskit/">tskit</a> package is installed,
with the <code class="docutils literal notranslate"><span class="pre">tskit</span> <span class="pre">vcf</span></code> command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tskit vcf foo.ts &gt; foo.vcf
</pre></div>
</div>
<p>For this small example (only five samples), the file sizes are similar,
but the tree sequence is slightly larger
(it does carry a good bit more information about the trees, after all).
However, if we up the sample sizes to 2000 and 3000
(the simulation is still pretty quick)
the tree sequence is twenty-three times smaller:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim HomSap -s <span class="m">1046</span> -g HapMapII_GRCh37 -c chr22 -o foo.ts -d OutOfAfrica_2T12 <span class="m">2000</span> <span class="m">3000</span>
<span class="gp">$ </span>tskit vcf foo.ts &gt; foo.vcf
<span class="gp">$ </span>ls -lth foo.*
<span class="go">-rw-r--r-- 1 peter peter 3139M Apr  3 10:40 foo.vcf</span>
<span class="go">-rw-r--r-- 1 peter peter  136M Apr  3 10:39 foo.ts</span>
</pre></div>
</div>
<p>Zipping the files (using the <a class="reference external" href="https://tszip.readthedocs.io/en/latest/">tszip</a>
package) reduces this difference quite a lot,
but increases time required for processing:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tskit vcf foo.ts <span class="p">|</span> gzip -c &gt; foo.vcf.gz
<span class="gp">$ </span>tszip foo.ts
<span class="gp">$ </span>ls -lth foo.*
<span class="go">-rw-r--r-- 1 peter peter  31M Apr  3 10:51 foo.ts.tsz</span>
<span class="go">-rw-r--r-- 1 peter peter  72M Apr  3 10:50 foo.vcf.gz</span>
</pre></div>
</div>
</section>
</section>
<section id="using-the-slim-simulation-engine">
<h3>Using the SLiM simulation engine<a class="headerlink" href="#using-the-slim-simulation-engine" title="Permalink to this headline"></a></h3>
<p>The default “simulation engine” -
i.e., the program that actually does the simulating -
is <a class="reference external" href="https://tskit.dev/msprime/">msprime</a>,
a coalescent simulator.
However, it is also possible to swap this out for
<a class="reference external" href="https://messerlab.org/slim/">SLiM</a>,
a forwards-time, individual-based simulator.</p>
<section id="specifying-the-engine">
<h4>Specifying the engine<a class="headerlink" href="#specifying-the-engine" title="Permalink to this headline"></a></h4>
<p>Using SLiM is as easy as passing the <code class="docutils literal notranslate"><span class="pre">--engine/-e</span></code> flag
(we didn’t do this above, so it used the default engine, msprime).
For instance, to use SLiM to simulate the same 5% chunk of chromosome 22
under the <code class="docutils literal notranslate"><span class="pre">OutOfAfrica_2T12</span></code> model as above,
we would just run:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim -e slim HomSap -c chr22 -l <span class="m">0</span>.05 -o foo.ts -d OutOfAfrica_2T12 <span class="m">2</span> <span class="m">4</span>
</pre></div>
</div>
<p>Here we’ve changed the sample sizes to be even:
SLiM simulates diploid individuals, but sample sizes are in numbers of chromosomes,
so if you ask for an odd number, it will be rounded up to an even number.
<strong>But:</strong> this simulation can take quite a while to run,
so before you try that command out, <strong>read on!</strong></p>
</section>
<section id="the-scaling-factor">
<span id="sec-slim-scaling-factor"></span><h4>The scaling factor<a class="headerlink" href="#the-scaling-factor" title="Permalink to this headline"></a></h4>
<p>However, even with only 5% of a chromosome,
that is a pretty big simulation, due to the large number of individuals
(unlike msprime, SLiM must actually simulate all the individuals in the population
even just to get a few samples).
To make it run fast enough for a tutorial,
we can specify a <em>scaling factor</em>,
described in more detail below (see <a class="reference internal" href="#sec-slim-scaling-factor"><span class="std std-ref">The scaling factor</span></a>),
using the <code class="docutils literal notranslate"><span class="pre">--slim-scaling-factor</span></code> option.
Unlike the previous command, this one should run very fast:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim -e slim --slim-scaling-factor <span class="m">10</span> HomSap <span class="se">\</span>
<span class="gp">$    </span>-c chr22 -l <span class="m">0</span>.05 -o foo.ts -d OutOfAfrica_2T12 <span class="m">2</span> <span class="m">4</span>
</pre></div>
</div>
<p>(Indeed, this example runs in less than a minute,
but without setting the scaling factor, leaving at its default of 1.0,
it takes on the same computer about 20 minutes.)
Briefly, what this does is reduces all the population sizes by a “scaling factor”
(here set to 10), and rescales time by the same factor,
thus increasing mutation, recombination, and population growth rates.
A model with selection would need to have selection coefficients multiplied by the factor as well.
This results in a model that is equivalent in many senses -
the same rate of genetic drift, the same expected decay of linkage disequilibrium -
but generally runs much faster because there are fewer individuals to keep track of.
In practice, rescaling seems to produce indistinguishable results in much shorter times
at many parameter values.
However, the user should be aware that in principle, the results are <strong>not</strong> equivalent,
possibly in subtle and hard-to-understand ways.
This is particularly true in simulations with large amounts of selection.
See the SLiM manual and/or
<a class="reference external" href="https://www.genetics.org/content/197/1/221.short">Urrichio &amp; Hernandez (2014)</a>
for more discussion.</p>
</section>
</section>
<section id="debugging-output-from-slim">
<h3>Debugging output from SLiM<a class="headerlink" href="#debugging-output-from-slim" title="Permalink to this headline"></a></h3>
<p>Next we’ll look at running a different model with SLiM,
but getting some sanity check output along the way.</p>
<section id="choose-a-species-drosophila-melanogaster">
<h4>Choose a species: Drosophila melanogaster<a class="headerlink" href="#choose-a-species-drosophila-melanogaster" title="Permalink to this headline"></a></h4>
<p>Perusing the <cite>Catalog &lt;sec_catalog&gt;</cite>,
we see that to simulate copies of chromosome arm 2L
from <em>Drosophila melanogaster</em> individuals with the demographic model
inferred by <a class="reference external" href="https://doi.org/10.1371/journal.pcbi.1004845">Sheehan &amp; Song (2016)</a>,
using SLiM with a (very large!) scaling factor of 1000, we could run</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim -e slim --slim-scaling-factor <span class="m">1000</span> DroMel<span class="se">\</span>
<span class="gp">$     </span>-c chr2L -l <span class="m">0</span>.05 -o foo.ts -d African3Epoch_1S16 <span class="m">100</span>
</pre></div>
</div>
<p>The scaling factor of 1000 makes this model run very quickly,
but should also make you <em>very</em> nervous.
What actually <em>is</em> being simulated here?
We can at least find out what the actual population sizes are in the SLiM simulation
by asking the simulation to be more verbose.
Prepending the <code class="docutils literal notranslate"><span class="pre">-v</span></code> flag will request that SLiM print out information
every time a demographic event occurs
(helpfully, this also gives us an idea of how quickly the simulation is going):
This also outputs a fair bit of other debugging output,
which can be turned off with <code class="docutils literal notranslate"><span class="pre">--quiet</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim -v -e slim --slim-scaling-factor <span class="m">1000</span> DroMel <span class="se">\</span>
<span class="gp">$     </span>-c chr2L -l <span class="m">0</span>.05 -o foo.ts -d African3Epoch_1S16 <span class="m">100</span> --quiet
</pre></div>
</div>
<p>Trimming down the output somewhat, we get:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">2020-04-03 22:05:52,160 [1098] DEBUG stdpopsim.species: Making flat chromosome 0.05 * chr2L</span>
<span class="go">2020-04-03 22:05:52,161 [1098] INFO stdpopsim.cli: Running simulation model African3Epoch_1S16 for DroMel on Contig(length=1.2E+06, recombination_rate=8.4E-09, mutation_rate=5.5E-09, genetic_map=None) with 100 samples using slim.</span>

<span class="go">1: sim.addSubpop(0, 652);</span>
<span class="go">1: Starting burn-in...</span>
<span class="go">6521: {dbg(self.source); p0.setSubpopulationSize(145);}</span>
<span class="go">8521: {dbg(self.source); p0.setSubpopulationSize(544);}</span>
<span class="go">8721: {dbg(self.source); inds=p0.sampleIndividuals(50); sim.treeSeqRememberIndividuals(inds);}</span>
<span class="go">8721: {dbg(self.source); end();}</span>
</pre></div>
</div>
<p>This tells us that after rescaling by a factor of 1000,
the population sizes in the three epochs are 652, 145, and 544 individuals,
respectively.
No wonder it runs so quickly!
At the end, fifty (diploid) individuals are sampled,
to get us our requested 100 genomes.
These numbers are not obviously completely wrong,
as would be for instance if we had population sizes of 1 or 2 individuals.
However, extensive testing would need to be done to find out
if data produced with such an extreme scaling factor
actually resembles the data that would be produced without rescaling.</p>
</section>
</section>
</section>
<section id="running-stdpopsim-with-the-python-interface-api">
<span id="sec-python-tute"></span><h2>Running stdpopsim with the Python interface (API)<a class="headerlink" href="#running-stdpopsim-with-the-python-interface-api" title="Permalink to this headline"></a></h2>
<p>Nearly all the functionality of <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> is available through the CLI,
but for complex situations it may be desirable to use python.
Furthermore, downstream analysis may happen in python,
using the <a class="reference external" href="https://tskit.dev/tskit/">tskit</a> tools for working
with tree sequences.
In order to use the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> API the <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> package must be
installed (see <a class="reference internal" href="installation.html#sec-installation"><span class="std std-ref">Installation</span></a>).</p>
<section id="running-a-published-model">
<span id="sec-tutorial-existing-models"></span><h3>Running a published model<a class="headerlink" href="#running-a-published-model" title="Permalink to this headline"></a></h3>
<p>The first example uses a mostly default genome
with a published demographic model.</p>
<section id="pick-a-species-and-demographic-model">
<h4>Pick a species and demographic model<a class="headerlink" href="#pick-a-species-and-demographic-model" title="Permalink to this headline"></a></h4>
<p>First, we will pick a species (here, humans) and the published demographic
model to simulated under. In <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> there are two types of model: ones
taken to match the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">demographic history reported in published papers</span></a>, and <a class="reference internal" href="api.html#sec-api-generic-models"><span class="std std-ref">“generic” models</span></a>. We’ll
first simulate using a published model from the catalog. Let’s see what
demographic models are available for humans:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stdpopsim</span>

<span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;HomSap&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">species</span><span class="o">.</span><span class="n">demographic_models</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

<span class="c1"># OutOfAfrica_3G09</span>
<span class="c1"># OutOfAfrica_2T12</span>
<span class="c1"># Africa_1T12</span>
<span class="c1"># AmericanAdmixture_4B11</span>
<span class="c1"># OutOfAfricaArchaicAdmixture_5R19</span>
<span class="c1"># Zigzag_1S14</span>
<span class="c1"># AncientEurasia_9K19</span>
<span class="c1"># PapuansOutOfAfrica_10J19</span>
<span class="c1"># AshkSub_7G19</span>
<span class="c1"># OutOfAfrica_4J17</span>
</pre></div>
</div>
<p>These models are described in detail in the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">Catalog</span></a>.
We’ll look at the first model, “OutOfAfrica_3G09”, from
<a class="reference external" href="https://doi.org/10.1371/journal.pgen.1000695">Gutenkunst et al (2009)</a>.
We can check how many populations exist in this model, and what they are:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_demographic_model</span><span class="p">(</span><span class="s2">&quot;OutOfAfrica_3G09&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span>
<span class="c1"># 3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">num_sampling_populations</span><span class="p">)</span>
<span class="c1"># 3</span>
<span class="nb">print</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">populations</span><span class="p">])</span>
<span class="c1"># [&#39;YRI&#39;, &#39;CEU&#39;, &#39;CHB&#39;]</span>
</pre></div>
</div>
<p>This model has 3 populations, named YRI, CEU, CHB, and all three can be sampled from.
The number of “sampling” populations could be smaller than the number of populations,
since some models have ancient populations which are currently not allowed to be
sampled from - but that is not the case in this model.</p>
</section>
<section id="set-up-the-contig">
<h4>Set up the contig<a class="headerlink" href="#set-up-the-contig" title="Permalink to this headline"></a></h4>
<p>We’ll next define the contig, which contains information about the genome length we
want to simulate and recombination and mutation rates. Here, we use the human
chromosome 22. If no recombination map is specified, we assume a uniform genetic map
based on the average recombination rate for that chromosome.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="s2">&quot;chr22&quot;</span><span class="p">)</span>

<span class="c1"># default is a flat genetic map</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mean recombination rate:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">contig</span><span class="o">.</span><span class="n">recombination_map</span><span class="o">.</span><span class="n">mean_rate</span><span class="si">:</span><span class="s2">.3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="c1"># mean recombination rate: 1.44e-08</span>

<span class="c1"># and the default mutation rate is based on the species default</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mean mutation rate:&quot;</span><span class="p">,</span> <span class="n">contig</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">)</span>
<span class="c1"># mean mutation rate: 1.29e-08</span>

<span class="c1"># but note that the mutation rate differs from the model&#39;s assumed rate</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;model mutation rate:&quot;</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">)</span>
<span class="c1"># model mutation rate: 2.35e-08</span>
</pre></div>
</div>
<p>The Gutenkunst OOA model was inferred using a mutation rate much larger than the
default mutation rate in the <cite>stdpopsim</cite> catalog. As such, simulating using this
model and default rate will result in levels of diversity substantially lower than
expected for the human population data that this model was inferred from. To match
observed diversity in humans, we should instead use the mutation rate associated
with the demographic model:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="s2">&quot;chr22&quot;</span><span class="p">,</span> <span class="n">mutation_rate</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">==</span> <span class="n">model</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">)</span>
<span class="c1"># True</span>
</pre></div>
</div>
</section>
<section id="choose-a-sampling-scheme-and-simulate">
<h4>Choose a sampling scheme and simulate<a class="headerlink" href="#choose-a-sampling-scheme-and-simulate" title="Permalink to this headline"></a></h4>
<p>The final ingredient we need before simulating
is a specification of the number of samples from each population.
We’ll simulate 10 samples each from YRI and CHB, and zero from CEU,
using <code class="docutils literal notranslate"><span class="pre">msprime</span></code> as the simulation engine:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;msprime&quot;</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
<span class="c1"># 88063</span>
</pre></div>
</div>
<p>And that’s it! It’s that easy! We now have a tree sequence
describing the history and genotypes of 20 genomes,
between which there are 88,063 variant sites.
(We didn’t set the random seed, though, so you’ll get a somewhat
different number.)</p>
<p>Let’s look at the metadata for the resulting simulation,
to make sure that we’ve got what we want.
The metadata for the populations is stored in json,
so we use the json module to easily parse it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>

<span class="n">ts</span><span class="o">.</span><span class="n">num_samples</span>
<span class="c1"># 20</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">populations</span><span class="p">()):</span>
    <span class="n">popdata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;The tree sequence has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="si">}</span><span class="s2"> samples from &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;population </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">, which is </span><span class="si">{</span><span class="n">popdata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="p">)</span>

<span class="c1"># The tree sequence has 10 samples from population 0, which is YRI.</span>
<span class="c1"># The tree sequence has 0 samples from population 1, which is CEU.</span>
<span class="c1"># The tree sequence has 10 samples from population 2, which is CHB.</span>
</pre></div>
</div>
</section>
</section>
<section id="running-a-generic-model">
<span id="sec-tutorial-generic-models"></span><h3>Running a generic model<a class="headerlink" href="#running-a-generic-model" title="Permalink to this headline"></a></h3>
<p>Next, we will simulate using a “generic” model, with piecewise constant
population size. This time, we will simulate a given genome length under
a flat recombination map, using an estimate of the
human effective population size from the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">Catalog</span></a>.</p>
<section id="choose-a-species">
<h4>Choose a species<a class="headerlink" href="#choose-a-species" title="Permalink to this headline"></a></h4>
<p>Although the model is generic, we still need a species in order
to get the contig information.
Again, we’ll use <cite>Homo sapiens</cite>, which has the id “HomSap”.
(But, you could use any species from the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">Catalog</span></a>!)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stdpopsim</span>

<span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;HomSap&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="set-up-the-generic-model">
<h4>Set up the generic model<a class="headerlink" href="#set-up-the-generic-model" title="Permalink to this headline"></a></h4>
<p>Next, we set the model to be the generic piecewise constant size model, using the
predefined human effective population size (see <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">Catalog</span></a>).
Since we are providing only one effective population size, the model is a
single population of constant over all time.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">PiecewiseConstantSize</span><span class="p">(</span><span class="n">species</span><span class="o">.</span><span class="n">population_size</span><span class="p">)</span>
</pre></div>
</div>
<p>Each species has a “default” population size, <code class="docutils literal notranslate"><span class="pre">species.population_size</span></code>,
which for humans is 10,000.</p>
</section>
<section id="choose-a-contig-and-recombination-map">
<h4>Choose a contig and recombination map<a class="headerlink" href="#choose-a-contig-and-recombination-map" title="Permalink to this headline"></a></h4>
<p>Next, we set the contig information. Again, we could use any of the chromosomes
listed in the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">Catalog</span></a> (or a fraction of a chromosome, using the
<code class="docutils literal notranslate"><span class="pre">length_multiplier</span></code> argument), keeping in mind that larger contigs will take
longer to simulate. We could also specify a “generic” contig, which provides
a segment of a given length with constant recombination rate, taken to be the
average rate over all chromosomes for that species. Here, we define a contig
of length 1 Mb:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
<span class="c1"># 1000000.0</span>
<span class="nb">print</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">recombination_map</span><span class="o">.</span><span class="n">mean_rate</span><span class="p">)</span>
<span class="c1"># 1.2313743222950562e-08</span>
<span class="nb">print</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">)</span>
<span class="c1"># 1.29e-8</span>
</pre></div>
</div>
<p>The “sequence length” is the length in base pairs. Since we are using a generic
contig, we cannot specify a recombination map so we get a “flat” map of
constant recombination rate. The mutation rate defaults to the species average
mutation rate, as no mutation rate was provided when defining the contig.</p>
</section>
<section id="id1">
<h4>Choose a sampling scheme, and simulate<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h4>
<p>Next, we set the number of samples and set the simulation engine.
In this case we will simulate genomes of 10 samples
using the simulation engine <cite>msprime</cite>.
But, you can go crazy with the sample size!
<cite>msprime</cite> is great at simulating large samples!</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;msprime&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we simulate the model with the contig length and number of samples we
defined above. The simulation results are recorded in a tree sequence object
(<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="sanity-check-the-tree-sequence-output">
<h4>Sanity check the tree sequence output<a class="headerlink" href="#sanity-check-the-tree-sequence-output" title="Permalink to this headline"></a></h4>
<p>Now, we do some simple checks that our simulation worked with
<a class="reference external" href="https://tskit.dev/tskit/">tskit</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
<span class="c1"># 10</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span>
<span class="c1"># 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">num_mutations</span><span class="p">)</span>
<span class="c1"># 1472</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">num_trees</span><span class="p">)</span>
<span class="c1"># 1078</span>
</pre></div>
</div>
<p>As expected, there are 10 samples in one population. We can also see that it
takes 1078 distinct genealogical trees across this 1Mb of sequence, on which
there were 1472 mutations (since we are not using a seed here, the number of
mutations and trees will be slightly different for you). Try running the
simulation again, and notice that the number of samples and populations stays
the same, while the number of mutations and trees changes.</p>
</section>
<section id="output-to-vcf">
<h4>Output to VCF<a class="headerlink" href="#output-to-vcf" title="Permalink to this headline"></a></h4>
<p>In addition to working directly with the simulated tree sequence, we can also output
other common formats used for population genetics analyses.
We can use <code class="docutils literal notranslate"><span class="pre">tskit</span></code> to convert the tree sequence to a vcf file called “foo.vcf”.
See the tskit documentation (<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.write_vcf" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.write_vcf()</span></code></a>) for more information.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;foo.vcf&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">vcf_file</span><span class="p">:</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">write_vcf</span><span class="p">(</span><span class="n">vcf_file</span><span class="p">,</span> <span class="n">contig_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Taking a look at the vcf file, we see something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>##fileformat=VCFv4.2
##source=tskit 0.3.5
##FILTER=&lt;ID=PASS,Description=&quot;All filters passed&quot;&gt;
##contig=&lt;ID=0,length=1000000&gt;
##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&gt;
#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  tsk_0   tsk_1   tsk_2   tsk_3   tsk_4   tsk_5   tsk_6   tsk_7   tsk_8   tsk_9
0       3608    .       A       T       .       PASS    .       GT      0       0       1       0       0       0       0       0       0       0
0       5598    .       T       G       .       PASS    .       GT      1       0       0       0       1       1       0       0       1       0
0       6190    .       C       A       .       PASS    .       GT      1       0       0       0       0       0       0       0       0       0
0       6479    .       C       T       .       PASS    .       GT      0       0       0       0       0       1       0       0       1       0
0       6556    .       A       C       .       PASS    .       GT      0       0       0       1       0       0       0       0       0       0
0       6648    .       T       A       .       PASS    .       GT      1       1       1       0       1       1       1       1       1       1
</pre></div>
</div>
</section>
</section>
<section id="using-the-slim-engine">
<h3>Using the SLiM engine<a class="headerlink" href="#using-the-slim-engine" title="Permalink to this headline"></a></h3>
<p>Above, we used the coalescent simulator <code class="docutils literal notranslate"><span class="pre">msprime</span></code>
as the simulation engine, which is in fact the default.
However, <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> also has the ability to produce
simulations with SLiM, a forwards-time, individual-based simulator.
Using SLiM provides us with a few more options.
You may also want to install the
<a class="reference external" href="https://tskit.dev/pyslim/">pyslim</a> package
to extract the additional SLiM-specific information
in the tree sequences that are produced.</p>
<section id="an-example-simulation">
<h4>An example simulation<a class="headerlink" href="#an-example-simulation" title="Permalink to this headline"></a></h4>
<p>The stdpopsim tool is designed so that different simulation engines
are more or less exchangeable, so that to run an equivalent
simulation with SLiM instead of msprime only requires specifying
SLiM as the <em>simulation engine</em>.
Here is a simple example.</p>
<section id="choose-the-species-contig-and-recombination-map">
<h5>Choose the species, contig, and recombination map<a class="headerlink" href="#choose-the-species-contig-and-recombination-map" title="Permalink to this headline"></a></h5>
<p>First, let’s set up a simulation of 10% of human chromosome 22
with a flat recombination map,
drawing 200 samples from the Tennesen et al (2012) model of African history,
<code class="docutils literal notranslate"><span class="pre">Africa_1T12</span></code>.
Since SLiM must simulate the entire population,
sample size does not affect the run time of the simulation,
only the size of the output tree sequence
(and, since the tree sequence format scales well with sample size,
it doesn’t affect this very much either).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stdpopsim</span>

<span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;HomSap&quot;</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_demographic_model</span><span class="p">(</span><span class="s2">&quot;Africa_1T12&quot;</span><span class="p">)</span>
<span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span>
    <span class="s2">&quot;chr22&quot;</span><span class="p">,</span> <span class="n">length_multiplier</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">mutation_rate</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">mutation_rate</span>
<span class="p">)</span>
<span class="c1"># default is a flat genetic map with average rate across chr22</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="choose-the-simulation-engine">
<h5>Choose the simulation engine<a class="headerlink" href="#choose-the-simulation-engine" title="Permalink to this headline"></a></h5>
<p>This time, we choose the <code class="docutils literal notranslate"><span class="pre">SLiM</span></code> engine,
but otherwise, things work pretty much just as before.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;slim&quot;</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>(Note: you have to have SLiM installed for this to work,
and if it isn’t installed in your <code class="docutils literal notranslate"><span class="pre">PATH</span></code>,
so that you can run it by just typing <code class="docutils literal notranslate"><span class="pre">slim</span></code> on the command line,
then you will need to specify the <code class="docutils literal notranslate"><span class="pre">slim_path</span></code> argument to <code class="docutils literal notranslate"><span class="pre">simulate</span></code>.)
To get an example that runs quickly,
we have set the <em>scaling factor</em>,
described in more detail above (<cite>sec_slim_scaling_factor</cite>),</p>
</section>
</section>
<section id="other-slim-options">
<h4>Other SLiM options<a class="headerlink" href="#other-slim-options" title="Permalink to this headline"></a></h4>
<p>Besides rescaling, there are a few additional options
specific to the SLiM engine, discussed here.</p>
<section id="the-slim-burn-in">
<h5>The SLiM burn-in<a class="headerlink" href="#the-slim-burn-in" title="Permalink to this headline"></a></h5>
<p>Another option specific to the SLiM engine is <code class="docutils literal notranslate"><span class="pre">slim_burn_in</span></code>:
the amount of time before the first demographic model change that SLiM begins simulating for,
in units of N generations, where N is the population size at the first demographic model change.
By default, this is set to 10, which is fairly safe.
History before this period is simulated with an <code class="docutils literal notranslate"><span class="pre">msprime</span></code> coalescent simulation,
called <a class="reference external" href="https://tskit.dev/pyslim/docs/latest/tutorial.html#recapitation">“recapitation”</a>
because it attaches tops to any trees that have not yet coalesced.
For instance, the <code class="docutils literal notranslate"><span class="pre">Africa_1T12</span></code> model
<a class="reference external" href="https://doi.org/10.1126/science.1219240">(Tennesen et al 2012)</a>
we used above has three distinct epochs:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stdpopsim</span>

<span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;HomSap&quot;</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_demographic_model</span><span class="p">(</span><span class="s2">&quot;Africa_1T12&quot;</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">get_demography_debugger</span><span class="p">()</span><span class="o">.</span><span class="n">print_history</span><span class="p">()</span>

<span class="c1"># =============================</span>
<span class="c1"># Epoch: 0 -- 204.6 generations</span>
<span class="c1"># =============================</span>
<span class="c1">#      start     end      growth_rate |     0</span>
<span class="c1">#    -------- --------       -------- | --------</span>
<span class="c1"># 0 |4.32e+05 1.45e+04         0.0166 |     0</span>

<span class="c1"># Events @ generation 204.6</span>
<span class="c1">#    - Population parameter change for 0: initial_size -&gt; 14474 growth_rate -&gt; 0</span>
<span class="c1"># ==================================</span>
<span class="c1"># Epoch: 204.6 -- 5920.0 generations</span>
<span class="c1"># ==================================</span>
<span class="c1">#      start     end      growth_rate |     0</span>
<span class="c1">#    -------- --------       -------- | --------</span>
<span class="c1"># 0 |1.45e+04 1.45e+04              0 |     0</span>

<span class="c1"># Events @ generation 5920.0</span>
<span class="c1">#    - Population parameter change for 0: initial_size -&gt; 7310</span>
<span class="c1"># ================================</span>
<span class="c1"># Epoch: 5920.0 -- inf generations</span>
<span class="c1"># ================================</span>
<span class="c1">#      start     end      growth_rate |     0</span>
<span class="c1">#    -------- --------       -------- | --------</span>
<span class="c1"># 0 |7.31e+03 7.31e+03              0 |     0</span>
</pre></div>
</div>
<p>Since the longest-ago epoch begins at 5,920 generations ago
with a population size of 7,310, if we set <code class="docutils literal notranslate"><span class="pre">slim_burn_in=0.1</span></code>,
then we’d run the SLiM simulation starting at 5,920 + 731 = 6,651 generations ago,
and anything <em>longer ago</em> than that would be simulated
with a msprime coalescent simulation.</p>
<p>To simulate 200 samples of all of human chromosome 22 in this way,
with the <code class="docutils literal notranslate"><span class="pre">HapMapII_GRCh37</span></code> genetic map,
we’d do the following
(again setting <code class="docutils literal notranslate"><span class="pre">slim_scaling_factor</span></code> to keep this example reasonably-sized):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span>
    <span class="s2">&quot;chr22&quot;</span><span class="p">,</span> <span class="n">genetic_map</span><span class="o">=</span><span class="s2">&quot;HapMapII_GRCh37&quot;</span><span class="p">,</span> <span class="n">mutation_rate</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">mutation_rate</span>
<span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;slim&quot;</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">slim_burn_in</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="outputting-the-slim-script">
<h5>Outputting the SLiM script<a class="headerlink" href="#outputting-the-slim-script" title="Permalink to this headline"></a></h5>
<p>One final option that could be useful
is that you can ask stdpopsim to output the SLiM model code directly,
without actually running the model.
You could then edit the code, to add other features not implemented in stdpopsim.
To do this, set <code class="docutils literal notranslate"><span class="pre">slim_script=True</span></code> (which prints the script to stdout;
here we capture it in a file):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">redirect_stdout</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;script.slim&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">contig</span><span class="p">,</span>
            <span class="n">samples</span><span class="p">,</span>
            <span class="n">slim_script</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>The resulting script is <em>big</em> - 18,122 lines -
because it has the actual HapMapII_GRCh37 genetic map for chromosome 22
included, as text.
To use it, you will at least want to edit it to save the tree sequence
to a reasonable location - searching for the string <code class="docutils literal notranslate"><span class="pre">trees_file</span></code>
you’ll find that the SLiM script currently saves the output to a
temporary file. So, for instance, after changing</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">defineConstant(&quot;trees_file&quot;, &quot;/tmp/tmp4hyf8ugn.ts&quot;);</span>
</pre></div>
</div>
<p>to</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">defineConstant(&quot;trees_file&quot;, &quot;foo.trees&quot;);</span>
</pre></div>
</div>
<p>we could then run the simulation in SLiM’s GUI,
to do more detailed investigation,
or we could just run it on the command line:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>slim script.slim
</pre></div>
</div>
<p>If you go this route, you need to do a few postprocessing steps
to the tree sequence that <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> usually does.
Happily, these are made available through a single python function,
<code class="xref py py-func docutils literal notranslate"><span class="pre">engine.recap_and_rescale</span></code>.
Back in python, we could do this by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stdpopsim</span><span class="o">,</span> <span class="nn">pyslim</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">pyslim</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;foo.trees&quot;</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">recap_and_rescale</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ts</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s2">&quot;foo_recap.trees&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The final line saves the tree sequence, now ready for analysis,
out again as <code class="docutils literal notranslate"><span class="pre">foo_recap.trees</span></code>.</p>
<p>The function
<code class="xref py py-func docutils literal notranslate"><span class="pre">engine.recap_and_rescale</span></code>
is doing three things.
The first, and most essential step, is undoing the rescaling of time
that the <code class="docutils literal notranslate"><span class="pre">slim_scaling_factor</span></code> has introduced.
Next is “recapitation”,
for which the rationale and method is described in detail in the
<a class="reference external" href="https://tskit.dev/pyslim/docs/latest/tutorial.html#recapitation">pyslim documentation</a>.
The third (and least crucial) step is to <em>simplify</em> the tree sequence.
If as above we ask for 200 samples from a population whose final size is
1,450 individuals (after rescaling),
then in fact the tree sequence returned by SLiM contains the entire genomes
and genealogies of all 1,450 individuals,
but stdpopsim throws away all the information that is extraneous
to the requested 100 (diploid) individuals,
using a procedure called
<code class="xref py py-meth docutils literal notranslate"><span class="pre">simplification</span></code>.
Having the extra individuals is not as wasteful as you might think,
because the size of the tree sequence grows very slowly with the number of samples.
However, for many analyses you will probably want to extract samples
of realistic size for real data.
Again, methods to do this are discussed in the
<a class="reference external" href="https://tskit.dev/pyslim/docs/latest/tutorial.html#simplification">pyslim documentation</a>.</p>
</section>
</section>
</section>
<section id="incorporating-selection">
<span id="sec-tute-selection"></span><h3>Incorporating selection<a class="headerlink" href="#incorporating-selection" title="Permalink to this headline"></a></h3>
<p>There are two general ways to incorporate selection into a simulation:
Currently, both ways only work using the SLiM engine.
The first way is by specifying a
<a class="reference internal" href="api.html#stdpopsim.DFE" title="stdpopsim.DFE"><code class="xref py py-class docutils literal notranslate"><span class="pre">distribution</span> <span class="pre">of</span> <span class="pre">fitness</span> <span class="pre">effects</span></code></a> for all new mutations
across the genome or in some subset of it.
This is demonstrated below on
<a class="reference external" href="sec_tute_genome_wide_dfe">the whole genome</a>,
on a given <a class="reference external" href="sec_tute_selection_single_gene">subset of the genome</a>,
and on <a class="reference external" href="sec_tute_selection_annotation">many subsets of the genome</a>
obtained from an <a class="reference internal" href="api.html#stdpopsim.Annotation" title="stdpopsim.Annotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotation</span></code></a>.
The second way is suitable for studying the effects of single
selective sweeps: we add a single mutation under selection,
as for instance in a <a class="reference external" href="sec_tute_selective_sweep">selective sweep</a>.</p>
<p>To make it so that new mutation added during the course of a simulation
can affect fitness,
we need to tell the contig where to put the mutations,
and what distribution of selection coefficients they will have.
To do this, we need to</p>
<ul class="simple">
<li><p>choose a distribution of fitness effects (a <a class="reference internal" href="api.html#stdpopsim.DFE" title="stdpopsim.DFE"><code class="xref py py-class docutils literal notranslate"><span class="pre">DFE</span></code></a>),</p></li>
<li><dl class="simple">
<dt>choose which part(s) of the Contig to apply the DFE to</dt><dd><p>(e.g., by choosing an <a class="reference internal" href="api.html#stdpopsim.Annotation" title="stdpopsim.Annotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotation</span></code></a>), and</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>add these to the <a class="reference internal" href="api.html#stdpopsim.Contig.add_dfe" title="stdpopsim.Contig.add_dfe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Contig</span></code></a>,</dt><dd><p>with the Annotation saying which portions of the genome the DFE
applies to.</p>
</dd>
</dl>
</li>
</ul>
<p>The next three examples demonstrate how to do this.</p>
<section id="simulating-with-a-genome-wide-dfe">
<span id="sec-tute-genome-wide-dfe"></span><h4>1. Simulating with a genome-wide DFE<a class="headerlink" href="#simulating-with-a-genome-wide-dfe" title="Permalink to this headline"></a></h4>
<p>In this example, we’ll add the Kim et al. HomSap/Gamma_K17 DFE to the
Gutenkunst et al. HomSap/OutOfAfrica_3G09 model.
We can see the DFEs available for a species in the catalog,
and get one using the <a class="reference internal" href="api.html#stdpopsim.Species.get_dfe" title="stdpopsim.Species.get_dfe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Species.get_dfe()</span></code></a> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;HomSap&quot;</span><span class="p">)</span>
<span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="s2">&quot;chr1&quot;</span><span class="p">,</span> <span class="n">length_multiplier</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>

<span class="n">dfe</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_dfe</span><span class="p">(</span><span class="s2">&quot;Gamma_K17&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dfe</span><span class="p">)</span>
</pre></div>
</div>
<p>Once we have the DFE, we can add it to the Contig,
specifying which set of <em>intervals</em> it will apply to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">contig</span><span class="o">.</span><span class="n">add_dfe</span><span class="p">(</span><span class="n">intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">length</span><span class="p">)]]),</span> <span class="n">DFE</span><span class="o">=</span><span class="n">dfe</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_demographic_model</span><span class="p">(</span><span class="s2">&quot;OutOfAfrica_3G09&quot;</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># YRI, CEU, CHB</span>
</pre></div>
</div>
<p>Now, we can simulate as usual:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;slim&quot;</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">contig</span><span class="p">,</span>
    <span class="n">samples</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">,</span>
    <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">slim_burn_in</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Let’s verify that we have both neutral and deleterious mutations in the resulting simulation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mut_info</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">mut</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">mutations</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">md</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mut</span><span class="o">.</span><span class="n">derived_state</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="n">mut</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;mutation_list&quot;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mut_info</span><span class="p">:</span>
            <span class="n">mut_info</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">md</span>

<span class="n">num_neutral</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mut_info</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;selection_coeff&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">mut_info</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="n">num_neutral</span><span class="si">}</span><span class="s2"> neutral mutations, and &quot;</span>
    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mut_info</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_neutral</span><span class="si">}</span><span class="s2"> nonneutral mutations.&quot;</span>
<span class="p">)</span>

<span class="c1"># There are 323 neutral mutations, and 420 nonneutral mutations.</span>
</pre></div>
</div>
</section>
<section id="simulating-selection-in-a-single-gene">
<span id="sec-tute-selection-single-gene"></span><h4>2. Simulating selection in a single gene<a class="headerlink" href="#simulating-selection-in-a-single-gene" title="Permalink to this headline"></a></h4>
<p>Next, we’ll simulate a 10kb gene flanked by 10kb neutral regions,
by specifying a particular interval to apply the HomSap/Gamma_K17 DFE to.
Contigs come by default covered by a neutral DFE,
so all we need to do is apply the DFE to the middle region
(which we’ll imagine is the coding region of a gene).
This works because
when a newly added DFE covers a portion of a Contig already covered by
previous DFEs, the new DFE takes precedence:
concretely, the intervals to which the new DFE apply
are removed from the intervals associated with previous DFEs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;HomSap&quot;</span><span class="p">)</span>
<span class="n">dfe</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_dfe</span><span class="p">(</span><span class="s2">&quot;Gamma_K17&quot;</span><span class="p">)</span>
<span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">30000</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_demographic_model</span><span class="p">(</span><span class="s2">&quot;OutOfAfrica_3G09&quot;</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># YRI, CEU, CHB</span>

<span class="n">gene_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">]])</span>
<span class="n">contig</span><span class="o">.</span><span class="n">add_dfe</span><span class="p">(</span><span class="n">intervals</span><span class="o">=</span><span class="n">gene_interval</span><span class="p">,</span> <span class="n">DFE</span><span class="o">=</span><span class="n">dfe</span><span class="p">)</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;slim&quot;</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">contig</span><span class="p">,</span>
    <span class="n">samples</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="mi">236</span><span class="p">,</span>
    <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">slim_burn_in</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We’ll count up the number of neutral and deleterious mutations in the three regions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_neutral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
<span class="n">num_del</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="n">gene_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span>
        <span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="n">gene_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">unique_muts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">mut</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ds</span><span class="p">,</span> <span class="n">md</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mut</span><span class="o">.</span><span class="n">derived_state</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="n">mut</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;mutation_list&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">ds</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_muts</span><span class="p">:</span>
                <span class="n">unique_muts</span><span class="p">[</span><span class="n">ds</span><span class="p">]</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;selection_coeff&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">unique_muts</span><span class="p">[</span><span class="n">ds</span><span class="p">]</span> <span class="o">==</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;selection_coeff&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">unique_muts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_neutral</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_del</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">num_neutral</span><span class="p">,</span> <span class="n">num_del</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;From </span><span class="si">{</span><span class="n">j</span> <span class="o">*</span> <span class="mi">1000</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> neutral mutations &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> deleterious mutations.&quot;</span>
    <span class="p">)</span>

<span class="c1"># From 0 to 1000: 50 neutral mutations and 0 deleterious mutations.</span>
<span class="c1"># From 1000 to 2000: 12 neutral mutations and 20 deleterious mutations.</span>
<span class="c1"># From 2000 to 3000: 45 neutral mutations and 0 deleterious mutations.</span>
</pre></div>
</div>
<p>This verifies that the only deleterious mutations are in the center bit,
and in the center there are both deleterious and neutral mutations,
as expected under the Gamma_K17.</p>
</section>
<section id="simulating-selection-on-exons">
<span id="sec-tute-selection-annotation"></span><h4>3. Simulating selection on exons<a class="headerlink" href="#simulating-selection-on-exons" title="Permalink to this headline"></a></h4>
<p>The catalog also has a certain number of <em>annotations</em> available,
obtained from Ensembl.
For instance, for humans we have:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">species</span><span class="o">.</span><span class="n">annotations</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">description</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># ensembl_havana_104_exons: Ensembl Havana exon annotations on GRCh38</span>
<span class="c1"># ensembl_havana_104_CDS: Ensembl Havana CDS annotations on GRCh38</span>
</pre></div>
</div>
<p>To simulate with the HomSap/Gamma_K17 DFE, now applied
to <em>all</em> exons on chromosome 21
(the remainder of the chromosome will have only neutral mutations),
we extract the intervals from the <a class="reference internal" href="api.html#stdpopsim.Annotation" title="stdpopsim.Annotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotation</span></code></a> object
and use this in <a class="reference internal" href="api.html#stdpopsim.Contig.add_dfe" title="stdpopsim.Contig.add_dfe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Contig.add_dfe()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;HomSap&quot;</span><span class="p">)</span>
<span class="n">dfe</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_dfe</span><span class="p">(</span><span class="s2">&quot;Gamma_K17&quot;</span><span class="p">)</span>
<span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="s2">&quot;chr20&quot;</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_demographic_model</span><span class="p">(</span><span class="s2">&quot;OutOfAfrica_3G09&quot;</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># YRI, CEU, CHB</span>

<span class="n">exons</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_annotations</span><span class="p">(</span><span class="s2">&quot;ensembl_havana_104_exons&quot;</span><span class="p">)</span>
<span class="n">exon_intervals</span> <span class="o">=</span> <span class="n">exons</span><span class="o">.</span><span class="n">get_chromosome_annotations</span><span class="p">(</span><span class="s2">&quot;chr20&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
<span class="n">contig</span><span class="o">.</span><span class="n">add_dfe</span><span class="p">(</span><span class="n">intervals</span><span class="o">=</span><span class="n">exon_intervals</span><span class="p">,</span> <span class="n">DFE</span><span class="o">=</span><span class="n">dfe</span><span class="p">)</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;slim&quot;</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">contig</span><span class="p">,</span>
    <span class="n">samples</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="mi">236</span><span class="p">,</span>
    <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">slim_burn_in</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Note the very large scaling factor ($Q=100$) that we’ve used here to get this
to run fast enough to be used for a quick example!
This is <em>not</em> expected to be a good example because of this extreme scaling,
but nonetheless there is lower diversity in exons than outside of them:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">breaks</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">contig</span><span class="o">.</span><span class="n">dfe_breakpoints</span><span class="p">()</span>

<span class="n">diffs</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span><span class="n">windows</span><span class="o">=</span><span class="n">breaks</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">pi</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diffs</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">breaks</span><span class="p">)[</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diffs</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">breaks</span><span class="p">)[</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]),</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Mean sequence diversity in exons is </span><span class="si">{</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> differences per Kb,</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;and outside of exons it is </span><span class="si">{</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> differences per Kb.&quot;</span>
<span class="p">)</span>

<span class="c1"># Mean sequence diversity in exons is 0.154 differences per Kb,</span>
<span class="c1"># and outside of exons it is 0.211 differences per Kb.</span>
</pre></div>
</div>
</section>
<section id="sec-tute-selective-sweep">
<span id="id2"></span><h4>4.  Selective sweep<a class="headerlink" href="#sec-tute-selective-sweep" title="Permalink to this headline"></a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The following interface for adding selective sweeps
is preliminary, and subject to change!</p>
</div>
<p>You may be interested in simulating and tracking a single mutation. To illustrate
this scenario, let’s simulate a selective sweep until it reaches an abitrary
allele frequency.</p>
<p>First, let’s define a contig and a demographic model; here, we are simulating a
small part of chromosome 2L of DroMel with a generic constant size demography.
The contig will be fully neutral, with the exception of the sweeping mutation
which we will insert later.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stdpopsim</span>

<span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;DroMel&quot;</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">PiecewiseConstantSize</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="s2">&quot;2L&quot;</span><span class="p">,</span> <span class="n">length_multiplier</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we need to set things up to add a selected mutation to a randomly chosen
chromosome in the population of our choice at a specific position in the contig.
We must also decide the time the mutation will be added, when selection will
start and at what frequency we want our selected mutation to be at the end of
the simulation.</p>
<p>Let’s assume the mutation appeared 1000 generations ago, it has a positive
effect on fitness (s=0.5). Also, we want the mutation to have reached a frequency
of at least 0.8 by the end. Next, we’ll walk through the steps required to do this:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that because we are doing a forward-in-time simulation, you should be
careful with your conditioning. For example, even a strongly selected mutation
would not be able to reach 80% frequency in just a few generations. Since
this conditioning works by re-running the simulation until the condition is
achieved, a nearly impossible condition will result in very long run times.</p>
</div>
<p>First, we need to define the mutation type for the selected mutation.
So we can refer to it later, we need its “mutation type ID”. This is just
the index of the new mutation type in the contig’s list of mutation types.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mt</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">MutationType</span><span class="p">(</span>
    <span class="n">distribution_type</span><span class="o">=</span><span class="s2">&quot;f&quot;</span><span class="p">,</span>
    <span class="n">dominance_coeff</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">distribution_args</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">],</span>
    <span class="n">convert_to_substitution</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">dfe</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">DFE</span><span class="p">(</span>
    <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;new_mutation&quot;</span><span class="p">,</span>
    <span class="n">mutation_types</span><span class="o">=</span><span class="p">[</span><span class="n">mt</span><span class="p">],</span>
    <span class="n">proportions</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;added mutation&quot;</span><span class="p">,</span>
    <span class="n">long_description</span><span class="o">=</span><span class="s2">&quot;mutation type to be added&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">contig</span><span class="o">.</span><span class="n">add_dfe</span><span class="p">(</span>
    <span class="n">intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">),</span>
    <span class="n">DFE</span><span class="o">=</span><span class="n">dfe</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">for</span> <span class="n">mt_info</span> <span class="ow">in</span> <span class="n">contig</span><span class="o">.</span><span class="n">mutation_types</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">mt_info</span><span class="p">[</span><span class="s2">&quot;dfe_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">dfe</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
        <span class="k">break</span>

<span class="n">mut_id</span> <span class="o">=</span> <span class="n">mt_info</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Next, we will set up the “extended events” which will modify the demography.
The first extended event is placing of the selected mutation,
which will occur in a random individual from the first population (id 0),
in the middle of the contig, 1000 generations ago.
We specify <code class="docutils literal notranslate"><span class="pre">save=True</span></code> to <code class="docutils literal notranslate"><span class="pre">stdpopsim.ext.DrawMutation</span></code>
so that the simulation can restart from that point if the mutation is lost.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">coordinate</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">T_mut</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">extended_events</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">stdpopsim</span><span class="o">.</span><span class="n">ext</span><span class="o">.</span><span class="n">DrawMutation</span><span class="p">(</span>
        <span class="n">time</span><span class="o">=</span><span class="n">T_mut</span><span class="p">,</span>
        <span class="n">mutation_type_id</span><span class="o">=</span><span class="n">mut_id</span><span class="p">,</span>
        <span class="n">population_id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">coordinate</span><span class="o">=</span><span class="n">coordinate</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Next, we condition on the mutation not being lost.
Since in the next step we condition on the mutation being at 80% frequency at
the end, this is redundant, but it allows the simulation to immediately restart
from any generation in which the mutation is lost, rather than waiting until the end.
Note that this conditioning must start one
generation after the mutation is placed, for which we use
<code class="docutils literal notranslate"><span class="pre">stdpopsim.ext.GenerationAfter(T_mut)</span></code>.
We cannot simply specify <code class="docutils literal notranslate"><span class="pre">T_mut</span> <span class="pre">-</span> <span class="pre">1</span></code> if rescaling is present,
otherwise the conditioning would start
at the same generation when the mutation is placed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">extended_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
    <span class="n">stdpopsim</span><span class="o">.</span><span class="n">ext</span><span class="o">.</span><span class="n">ConditionOnAlleleFrequency</span><span class="p">(</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">stdpopsim</span><span class="o">.</span><span class="n">ext</span><span class="o">.</span><span class="n">GenerationAfter</span><span class="p">(</span><span class="n">T_mut</span><span class="p">),</span>
        <span class="n">end_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">mutation_type_id</span><span class="o">=</span><span class="n">mut_id</span><span class="p">,</span>
        <span class="n">population_id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">op</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
        <span class="n">allele_frequency</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Finally, we condition on the mutation being above 80% at the end of the simulation.
(The “end” is at time 0, since “time” is in generations before the end of the simulation.)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">extended_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
    <span class="n">stdpopsim</span><span class="o">.</span><span class="n">ext</span><span class="o">.</span><span class="n">ConditionOnAlleleFrequency</span><span class="p">(</span>
        <span class="n">start_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">mutation_type_id</span><span class="o">=</span><span class="n">mut_id</span><span class="p">,</span>
        <span class="n">population_id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">op</span><span class="o">=</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span>
        <span class="n">allele_frequency</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now we can simulate, using SLiM of course.
For comparison, we will run the same simulation
without selection - i.e., without the “extended events”:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;slim&quot;</span><span class="p">)</span>
<span class="n">ts_sweep</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">contig</span><span class="p">,</span>
    <span class="n">samples</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">,</span>
    <span class="n">extended_events</span><span class="o">=</span><span class="n">extended_events</span><span class="p">,</span>
    <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">slim_burn_in</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">ts_neutral</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">contig</span><span class="p">,</span>
    <span class="n">samples</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">,</span>
    <span class="c1"># no extended events</span>
    <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">slim_burn_in</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Lastly, we can directly compute nucleotide diversity in 10Kb windows for both the
neutral and sweep simulations and plot them side by side.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ts_neutral</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)]</span>
<span class="n">windows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ts_neutral</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">))</span>
<span class="n">neutral_pi</span> <span class="o">=</span> <span class="n">ts_neutral</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span><span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">)</span>
<span class="n">sweep_pi</span> <span class="o">=</span> <span class="n">ts_sweep</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span><span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neutral_pi</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;neutral&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sweep_pi</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;sweep&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Genomic window&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Diversity&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/tute-sweep.png"><img alt="Plot with nucleotide diversity along the chromosome for simulations with a without a selective sweep." class="align-center" src="_images/tute-sweep.png" style="width: 500px;" /></a>
</section>
</section>
</section>
<section id="example-analyses-with-stdpopsim">
<span id="sec-tute-analyses"></span><h2>Example analyses with <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code><a class="headerlink" href="#example-analyses-with-stdpopsim" title="Permalink to this headline"></a></h2>
<section id="calculating-genetic-divergence">
<span id="sec-tute-divergence"></span><h3>Calculating genetic divergence<a class="headerlink" href="#calculating-genetic-divergence" title="Permalink to this headline"></a></h3>
<p>Next we’ll give an example of computing some summaries of the simulation output.
The <a class="reference external" href="https://tskit.dev/tskit/docs/stable/">tskit</a>  documentation
has details on many more statistics that you can compute using the tree sequences.
We will simulate some samples of human chromosomes
from different populations,
and then estimate the genetic divergence between each population pair.</p>
<section id="simulating-the-dataset">
<h4>1. Simulating the dataset<a class="headerlink" href="#simulating-the-dataset" title="Permalink to this headline"></a></h4>
<p>First, let’s use the <code class="docutils literal notranslate"><span class="pre">--help-models</span></code> option to see the selection of demographic
models available to us:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ stdpopsim HomSap --help-models

All simulation models for Homo sapiens

OutOfAfricaExtendedNeandertalAdmixturePulse_3I21: Three population out-of-Africa with an extended pulse of         Neandertal admixture into Europeans
     Demographic model af an extended admixture pulse from Neandertals
    into Europenas taken from Iasi et al. (2021). This model simulates
    3 populations: Africans, Europeans and Neandertals with an Out-of-
    Africa event. The population sizes are constant with an
    unidirectional admixture from Neandertals into Europeans after the
    split between Europeans and Africans. The admixture event is
    modelled as an 800 generation (20 ky) long extended admixture
    pulse.

    Populations:
        0: 1000 Genomes YRI (Yorubans)
        1: 1000 Genomes CEU (Utah Residents             (CEPH) with Northern and Western European Ancestry
        2: Neandertals

OutOfAfrica_3G09: Three population out-of-Africa
     The three population Out-of-Africa model from Gutenkunst et al.
...
</pre></div>
</div>
<p>This prints detailed information about all of the available models to
the terminal.
In this tutorial, we will use the model of African-American admixture from
<a class="reference external" href="http://dx.doi.org/10.1371/journal.pgen.1007385">2011 Browning et al</a>.
From the help output (or the <a class="reference internal" href="catalog.html#sec_catalog_homsap_models_americanadmixture_4b11"><span class="std std-ref">Catalog</span></a>),
we can see that this model has id <code class="docutils literal notranslate"><span class="pre">AmericanAdmixture_4B11</span></code>,
and allows samples to be drawn from 4 contemporary populations representing African,
European, Asian and African-American groups.</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">--help-genetic-maps</span></code> option, we can also see what recombination maps
are available:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ stdpopsim HomSap --help-genetic-maps

All genetic maps for Homo sapiens

HapMapII_GRCh37
     This genetic map is from the Phase II Hapmap project and based on
    3.1 million genotyped SNPs from 270 individuals across four
    populations (YRI, CEU, CHB and JPT). Genome wide recombination
    rates were estimated using LDHat. This version of the HapMap
    genetic map was lifted over to GRCh37 (and adjusted in regions
    where the genome assembly had rearranged) for use in the 1000
    Genomes project. Please see the README file on the 1000 Genomes
    download site for details of these adjustments. ftp://ftp-trace.nc
    bi.nih.gov/1000genomes/ftp/technical/working/20110106_recombinatio
    n_hotspots

DeCodeSexAveraged_GRCh36
     This genetic map is from the deCode study of recombination events
    in 15,257 parent-offspring pairs from Iceland. 289,658 phased
    autosomal SNPs were used to call recombinations within these
    families, and recombination rates computed from the density of
...
</pre></div>
</div>
<p>Let’s go with <code class="docutils literal notranslate"><span class="pre">HapMapII_GRCh37</span></code>.
The next command simulates 4 samples of chromosome 1 from each of the four
populations, and saves the output to a file called <code class="docutils literal notranslate"><span class="pre">afr-america-chr1.trees</span></code>.
For the purposes of this tutorial, we’ll also specify a random seed using the
<code class="docutils literal notranslate"><span class="pre">-s</span></code> option.
To check that we have set up the simulation correctly, we may first wish to perform a
dry run using the <code class="docutils literal notranslate"><span class="pre">-D</span></code> option.
This will print information about the simulation to the terminal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ stdpopsim HomSap -c chr1 -o afr-america-chr1.trees -s 13 -g HapMapII_GRCh37 -d AmericanAdmixture_4B11 4 4 4 4 -D
WARNING: Recombination map has length 249218992.0, which is longer than chromosome length 248956422. The former will be used.
Simulation information:
    Engine: msprime (1.0.3)
    Model id: AmericanAdmixture_4B11
    Model desciption: American admixture
    Seed: 13
    Population: number_samples (sampling_time_generations):
        0: 4 (0)
        1: 4 (0)
        2: 4 (0)
        3: 4 (0)
Contig Description:
    Contig length: 249218992.0
    Mean recombination rate: 1.1489616300318414e-08
    Mean mutation rate: 2.36e-08
    Genetic map: HapMapII_GRCh37

The provenance information for the resulting tree sequence is 8.79MB. This is nothing to worry about as provenance is a good thing to have, but if you want to save this memory/storage space you can disable provenance recording by setting record_provenance=False
If you use this simulation in published work, please cite:
[stdpopsim]
Adrion et al., 2020: https://doi.org/10.7554/eLife.54967
[simulation engine]
Kelleher et al., 2016: https://doi.org/10.1371/journal.pcbi.1004842
[generation time]
Tremblay and Vézina, 2000: https://doi.org/10.1086/302770
[population size]
Takahata, 1993: https://doi.org/10.1093/oxfordjournals.molbev.a039995
[genome assembly]
International Human Genome Sequencing Consortium, 2001: http://dx.doi.org/10.1038/35057062
[recombination rate, genetic map]
The International HapMap Consortium, 2007: https://doi.org/10.1038/nature06258
[demographic model]
Browning et al., 2018: http://dx.doi.org/10.1371/journal.pgen.1007385
[demographic model]
Gravel et al., 2011: https://doi.org/10.1073/pnas.1019276108
</pre></div>
</div>
<p>Once we’re sure, we can remove the <code class="docutils literal notranslate"><span class="pre">-D</span></code> flag to run the simulation. (Note: This took around 8 minutes to run on a laptop.)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stdpopsim HomSap -c chr1 -o afr-america-chr1.trees -s <span class="m">13</span> -g HapMapII_GRCh37 -d AmericanAdmixture_4B11 <span class="m">4</span> <span class="m">4</span> <span class="m">4</span> <span class="m">4</span>
</pre></div>
</div>
</section>
<section id="calculating-divergences">
<h4>2. Calculating divergences<a class="headerlink" href="#calculating-divergences" title="Permalink to this headline"></a></h4>
<p>We should now have a file called <code class="docutils literal notranslate"><span class="pre">afr-america-chr1.trees</span></code>.
Our work with <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> is done; we’ll now switch to a Python console and import
the <code class="docutils literal notranslate"><span class="pre">tskit</span></code> package to load and analyse this simulated tree sequence file.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tskit</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;afr-america-chr1.trees&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Recall that <cite>genetic divergence</cite> (often denoted <span class="math notranslate nohighlight">\(d_{xy}\)</span>)
between two populations is the mean density per nucleotide
of sequence differences between two randomly sampled chromosomes,
one from each population
(and averaged over pairs of chromosomes).
<cite>Genetic diversity</cite> of a population (often denoted <span class="math notranslate nohighlight">\(\pi\)</span>) is the same quantity,
but with both chromosomes sampled from the same population.
These quantities can be computed directly from our sample using tskit’s
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.divergence" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.divergence()</span></code></a>.</p>
<p>By looking at
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.divergence" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">the</span> <span class="pre">documentation</span></code></a>
for this method, we can see that we’ll need two inputs: <code class="docutils literal notranslate"><span class="pre">sample_sets</span></code> and
<code class="docutils literal notranslate"><span class="pre">indexes</span></code>.
In our case, we want <code class="docutils literal notranslate"><span class="pre">sample_sets</span></code> to give the list
of sample chromosomes (nodes) from each separate population.
We can obtain the necessary list of lists like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sample_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">):</span>
    <span class="n">sample_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sample_list</span><span class="p">)</span>

<span class="c1"># [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]</span>
</pre></div>
</div>
<p>Note that the samples with node IDs 0 - 3 are from population 0,
samples with node IDs 4 - 7 are from population 1 and so on.
(Also, the <code class="docutils literal notranslate"><span class="pre">.tolist()</span></code> in the code above is not necessary;
it is only there to make the output simpler.)</p>
<p>The next argument, <code class="docutils literal notranslate"><span class="pre">indexes</span></code> should give the pairs of integer indexes
corresponding to the sample sets that we wish to compute divergence between.
For instance, the tuple <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">2)</span></code> will compute the divergence between
sample set 0 and sample set 2 (so, in our case, population 0 and population 2).
We can quickly get all the pairs of indexes as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">):</span>
        <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
<span class="c1"># [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]</span>
</pre></div>
</div>
<p>We are now ready to calculate the genetic divergences.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">divs</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">divergence</span><span class="p">(</span><span class="n">sample_sets</span><span class="o">=</span><span class="n">sample_list</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">inds</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">divs</span><span class="p">)</span>
<span class="c1"># array([0.00035424, 0.0003687 , 0.00036707, 0.0003705 , 0.00026696,</span>
<span class="c1">#        0.00029148, 0.00029008, 0.00025767, 0.0002701 , 0.00028184])</span>
</pre></div>
</div>
<p>As a sanity check, this demographic model has population sizes of around <span class="math notranslate nohighlight">\(N_e = 10^4\)</span>,
and the mutation rate is <span class="math notranslate nohighlight">\(\mu = 1.29 \times 10^{-8}\)</span>
(shown in the output of <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code>, or found in python with <code class="docutils literal notranslate"><span class="pre">contig.mutation_rate</span></code>),
so we expect divergence values to be of order of magnitude <span class="math notranslate nohighlight">\(2 N_e \mu = 0.000254\)</span>,
slightly higher because of population structure.</p>
</section>
<section id="plotting-the-divergences">
<h4>3. Plotting the divergences<a class="headerlink" href="#plotting-the-divergences" title="Permalink to this headline"></a></h4>
<p>The output lists the divergences of all population pairs that are specified in
<code class="docutils literal notranslate"><span class="pre">indexes</span></code>, in the same order.
However, instead of simply printing these values to the console, it might be nicer
to create a heatmap of the values.
Here is some (more advanced) code that does this.
It relies on the <code class="docutils literal notranslate"><span class="pre">numpy</span></code>, <code class="docutils literal notranslate"><span class="pre">seaborn</span></code> and <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> packages.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">div_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">))</span>
<span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)):</span>
    <span class="n">pop0</span><span class="p">,</span> <span class="n">pop1</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
    <span class="n">div_matrix</span><span class="p">[</span><span class="n">pop0</span><span class="p">,</span> <span class="n">pop1</span><span class="p">]</span> <span class="o">=</span> <span class="n">divs</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
    <span class="n">div_matrix</span><span class="p">[</span><span class="n">pop1</span><span class="p">,</span> <span class="n">pop0</span><span class="p">]</span> <span class="o">=</span> <span class="n">divs</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
<span class="n">seaborn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">div_matrix</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">,</span> <span class="n">square</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Genetic divergence&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Populations&quot;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Populations&quot;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s2">&quot;AFR&quot;</span><span class="p">,</span> <span class="s2">&quot;EUR&quot;</span><span class="p">,</span> <span class="s2">&quot;ASI&quot;</span><span class="p">,</span> <span class="s2">&quot;ADM&quot;</span><span class="p">],</span> <span class="n">minor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="s2">&quot;AFR&quot;</span><span class="p">,</span> <span class="s2">&quot;EUR&quot;</span><span class="p">,</span> <span class="s2">&quot;ASI&quot;</span><span class="p">,</span> <span class="s2">&quot;ADM&quot;</span><span class="p">],</span> <span class="n">minor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/tute-divergence.png"><img alt="Heatmap of divergence values." class="align-center" src="_images/tute-divergence.png" style="width: 400px; height: 265px;" /></a>
<p>These values make sense given the model of demography we have specified:
the highest divergence estimates were obtained when African samples (AFR) were
compared with samples from other populations, and the lowest divergence
estimates were obtained when Asian (ASI) samples were compared with themselves.
However, the overwhelming sameness of the sample chromosomes is also evident:
on average, any two sample chromosomes differ at less than 0.04% of positions,
regardless of the populations they come from.</p>
</section>
</section>
<section id="calculating-the-allele-frequency-spectrum">
<span id="sec-tute-sfs"></span><h3>Calculating the allele frequency spectrum<a class="headerlink" href="#calculating-the-allele-frequency-spectrum" title="Permalink to this headline"></a></h3>
<p>Next, we will simulate some samples of chromosomes from different populations of
a non-human (finally!), <em>Arabidopsis thaliana</em>,
and analyse the allele frequency spectrum (AFS) for each population
(also called the “site frequency spectrum, or SFS).</p>
<section id="id3">
<h4>1. Simulating the dataset<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h4>
<p>This time, we will use the <a class="reference internal" href="api.html#stdpopsim.IsolationWithMigration" title="stdpopsim.IsolationWithMigration"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stdpopsim.IsolationWithMigration()</span></code></a> model.
Since this is a generic model that can be used for any species, we must use the Python
interface for this simulation.
See our <a class="reference internal" href="#sec-python-tute"><span class="std std-ref">Python tutorial</span></a> for an introduction to this interface.</p>
<p>We begin by importing <code class="docutils literal notranslate"><span class="pre">stdpopsim</span></code> into a Python environment and specifying our desired
species, <em>Arabidopsis thaliana</em>. From the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">Catalog</span></a>, we can see that this
species has the ID <code class="docutils literal notranslate"><span class="pre">AraTha</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stdpopsim</span>

<span class="n">species</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_species</span><span class="p">(</span><span class="s2">&quot;AraTha&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>After skimming the <a class="reference internal" href="catalog.html#sec-catalog"><span class="std std-ref">Catalog</span></a> to see our options, we’ll specify our
desired chromosome <code class="docutils literal notranslate"><span class="pre">chr4</span></code> and recombination map <code class="docutils literal notranslate"><span class="pre">SalomeAveraged_TAIR7</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">contig</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">get_contig</span><span class="p">(</span><span class="s2">&quot;chr4&quot;</span><span class="p">,</span> <span class="n">genetic_map</span><span class="o">=</span><span class="s2">&quot;SalomeAveraged_TAIR7&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>From the API description, we can see that the <a class="reference internal" href="api.html#stdpopsim.IsolationWithMigration" title="stdpopsim.IsolationWithMigration"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stdpopsim.IsolationWithMigration()</span></code></a>
model allows us to sample from a pair of populations that diverged from a common
ancestral population. We’ll specify that the effective population size of the ancestral
population was 5000, that the population sizes of the two modern populations are 4000
and 1000, that the populations diverged 1000 generations ago,
and that rates of migration since the split between the populations are both zero.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">IsolationWithMigration</span><span class="p">(</span>
    <span class="n">NA</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">N1</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">N2</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">M12</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M21</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We’ll simulate 10 chromosomes from each of the populations using the <code class="docutils literal notranslate"><span class="pre">msprime</span></code> engine.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="s2">&quot;msprime&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we’ll run a simulation using the objects we’ve created and store the outputted
dataset in an object called <code class="docutils literal notranslate"><span class="pre">ts</span></code>. For the purposes of this tutorial, we’ll also run this
simulation using a random seed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="calculating-the-afs">
<h4>2. Calculating the AFS<a class="headerlink" href="#calculating-the-afs" title="Permalink to this headline"></a></h4>
<p>Recall that the <em>allele frequency spectrum</em> (AFS) summarises the distribution of allele
frequencies in a given sample.
At each site, there is an ancestral and (sometimes more than one) derived allele,
and each allele is observed in the sample with some frequency.
Each entry in the AFS corresponds to a particular sample frequency,
and records the total number of derived alleles with that frequency.
We can calculate the AFS directly from our tree sequence using the
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.allele_frequency_spectrum" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.allele_frequency_spectrum()</span></code></a> method.</p>
<p>Since we wish to find the AFS separately for each of our two populations, we will
first need to know which samples correspond to each population.
The <a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.samples" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.samples()</span></code></a>
method in tskit allows us to find the IDs of samples from each population:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pop_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pop_samples</span><span class="p">)</span>
<span class="c1"># [array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32),</span>
<span class="c1">#  array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19], dtype=int32)]</span>
</pre></div>
</div>
<p>We are now ready to calculate the AFS.
Since our dataset was generated using the default <code class="docutils literal notranslate"><span class="pre">msprime</span></code> simulation engine,
we know that it has exactly one derived allele at any polymorphic site.
We also know what the derived and ancestral states are.
We can therefore calculate the <em>polarised</em> AFS using tskit’s
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.allele_frequency_spectrum" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.allele_frequency_spectrum()</span></code></a> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sfs0</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">allele_frequency_spectrum</span><span class="p">(</span>
    <span class="n">sample_sets</span><span class="o">=</span><span class="p">[</span><span class="n">pop_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">polarised</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sfs0</span><span class="p">)</span>
<span class="c1"># [1603. 2523. 1259.  918.  598.  471.  434.  367.  343.  265.  136.]</span>
</pre></div>
</div>
<p>The output lists the number of derived alleles that are found in 0, 1, 2, …
of the given samples. Since each of our populations have 10 samples each,
there are 11 numbers.
The first number, 1603, is the number of derived alleles found in the tree sequence
but not found in that population at all (they are present because they are found in the
<em>other</em> population).
The second, 2523, is the number of singletons, and so forth.
The final number, 136, is the number of derived alleles in the tree sequence found in <em>all</em>
ten samples from this population.
Since an msprime simulation only contains information about polymorphic alleles,
these must be alleles fixed in this population but still polymorphic in the other.</p>
<p>Here is the AFS for the other population:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sfs1</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">allele_frequency_spectrum</span><span class="p">(</span>
    <span class="n">sample_sets</span><span class="o">=</span><span class="p">[</span><span class="n">pop_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">polarised</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sfs1</span><span class="p">)</span>
<span class="c1"># [3755.  972.  744.  558.  476.  502.  409.  320.  306.  271.  604.]</span>
</pre></div>
</div>
<p>The somewhat mysterious <code class="docutils literal notranslate"><span class="pre">polarised=True</span></code> option indicates that we wish to
calculate the AFS for derived alleles only, without “folding” the spectrum,
and the <code class="docutils literal notranslate"><span class="pre">span_normalise=False</span></code> option disables tskit’s
default behaviour of dividing by the sequence length. See
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/stats.html#interface">tskit’s documentation</a>
for more information on these options.</p>
<p>We will do further analysis in the next section, but you might first wish to convince
yourself that this output makes sense to you.
You might also wish to check that the total sum of sites is the sum of the AFS entries:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">sfs0</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sfs1</span><span class="p">),</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_sites</span>
<span class="c1"># (8917.0, 8917.0, 8917)</span>
</pre></div>
</div>
</section>
<section id="plotting-the-afs">
<h4>3. Plotting the AFS<a class="headerlink" href="#plotting-the-afs" title="Permalink to this headline"></a></h4>
<p>Here is some more advanced code that compares the estimated AFS from each population.
It relies on the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy</span></code> packages.
We will scale each AFS by the number of mutated sites in the corresponding sample set.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">bar_width</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">r1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.2</span>
<span class="n">r2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">bar_width</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">r1</span><span class="p">]</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">sfs0</span> <span class="o">/</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">bar_width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;pop0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">r2</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">sfs1</span> <span class="o">/</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">bar_width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;pop1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Allele count&quot;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Proportion of mutated sites in sample&quot;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="AFS plots." class="align-center" src="_images/tute-sfs.png" />
<p>This figure shows substantial differences in the allele frequency spectrum
between the two populations,
most notably a larger number of singletons in population 0
and a larger number of fixed and absent alleles in population 1.
This makes sense given the demography we have specified:
population 1 has had a much more extreme population size reduction.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="catalog.html" class="btn btn-neutral float-left" title="Catalog" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="cli_arguments.html" class="btn btn-neutral float-right" title="Command-line options" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020, PopSim Consortium.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>