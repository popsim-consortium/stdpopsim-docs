

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>stdpopsim.selection &mdash; stdpopsim 0.2.1a2.dev72+g8110013 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=dc93f7aa" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=00e79c11"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            stdpopsim
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../catalog.html">Catalog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli_arguments.html">Command-line options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelogs.html">Changelogs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">stdpopsim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">stdpopsim.selection</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for stdpopsim.selection</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">attr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenerationAfter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We often want to do things one generation after another event. This class</span>
<span class="sd">    is essentially just a marker so that the SLiM engine can calculate the next</span>
<span class="sd">    generation by taking into account the scaling parameter Q.</span>
<span class="sd">    We call float(generation_after_obj) to get the time value.</span>

<span class="sd">    XXX: Rename this? GenerationAfter means the generation after something</span>
<span class="sd">         in a forwards-time convention, but times are specified with units of</span>
<span class="sd">         generations before the present!</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">validate_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">validate_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative times are invalid.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">GenerationAfter</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The generation after time=0 is in the future.&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">validate_time_range</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">):</span>
    <span class="n">validate_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
    <span class="n">validate_time</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_time</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_time=</span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2"> &lt; end_time=</span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">float</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">GenerationAfter</span><span class="p">)</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">GenerationAfter</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;start_time=GenerationAfter(</span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2">) &lt; end_time=</span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ExtendedEvent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ExtendedEvent is analogous to msprime.DemographicEvent, but is used here</span>
<span class="sd">    for explicitly manipulating mutations. Currently, these are only used by</span>
<span class="sd">    the SLiM engine. Times are all in units of generations before the present,</span>
<span class="sd">    just like for msprime.DemographicEvent.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DrawMutation</span><span class="p">(</span><span class="n">ExtendedEvent</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Introduce a new mutation with the given mutation type in the given</span>
<span class="sd">    population at a given single site. The mutation will be added to one</span>
<span class="sd">    randomly chosen chromosome in the given population. Only one mutation</span>
<span class="sd">    may be drawn per single site.</span>

<span class="sd">    :ivar time: The number of generations in the past at which to introduce the</span>
<span class="sd">        mutation.</span>
<span class="sd">    :vartype start_time: float</span>
<span class="sd">    :ivar single_site_id: The string ID of the single site at which to</span>
<span class="sd">        introduce the mutation, see :meth:`Contig.add_single_site`.</span>
<span class="sd">    :vartype single_site_id: str</span>
<span class="sd">    :ivar population: The name of the population in which to introduce</span>
<span class="sd">        the mutation.</span>
<span class="sd">    :vartype population: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">single_site_id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">validate_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ChangeMutationFitness</span><span class="p">(</span><span class="n">ExtendedEvent</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the selection and/or dominance coefficients for the given mutation</span>
<span class="sd">    type in the given population. The mutation this applies to need not exist</span>
<span class="sd">    in the population for all generations between start_time and end_time.</span>
<span class="sd">    E.g. if the mutation could be transferred to the population via migration.</span>
<span class="sd">    This requires that a `DrawMutation` event with the same `single_site_id` is</span>
<span class="sd">    also supplied to the simulation engine.</span>

<span class="sd">    See SLiM documentation for registerFitnessCallback().</span>

<span class="sd">    :ivar start_time: The number of generations in the past at which the change</span>
<span class="sd">        in mutation fitness begins.</span>
<span class="sd">    :vartype start_time: float</span>
<span class="sd">    :ivar end_time: The number of generations in the past at which the change</span>
<span class="sd">        in mutation fitness ends.</span>
<span class="sd">    :vartype end_time: float</span>
<span class="sd">    :ivar single_site_id: The string ID of the single site at which to change</span>
<span class="sd">        the mutation fitness, see :meth:`Contig.add_single_site`.</span>
<span class="sd">    :vartype single_site_id: str</span>
<span class="sd">    :ivar population: The name of the population in which to change</span>
<span class="sd">        the mutation fitness. If `None` (the default), then all populations are</span>
<span class="sd">        affected.</span>
<span class="sd">    :vartype population: str</span>
<span class="sd">    :ivar selection_coeff: The new selection coefficient of the mutation.</span>
<span class="sd">    :vartype selection_coeff: float</span>
<span class="sd">    :ivar dominance_coeff: The new dominance coefficient of the mutation.</span>
<span class="sd">    :vartype dominance_coeff: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">single_site_id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">selection_coeff</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">dominance_coeff</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">validate_time_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ConditionOnAlleleFrequency</span><span class="p">(</span><span class="n">ExtendedEvent</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Condition on the allele frequency of a drawn mutation with the given</span>
<span class="sd">    mutation type in the given population. The mutation need not have been</span>
<span class="sd">    drawn in the population being conditioned upon.  This requires that a</span>
<span class="sd">    `DrawMutation` event for the same single site is also supplied to the</span>
<span class="sd">    simulation engine.</span>

<span class="sd">    :ivar start_time: The number of generations in the past at which to start</span>
<span class="sd">        checking the allele frequency condition.</span>
<span class="sd">    :vartype start_time: float</span>
<span class="sd">    :ivar end_time: The number of generations in the past at which to stop</span>
<span class="sd">        checking the allele frequency condition.</span>
<span class="sd">    :vartype end_time: float</span>
<span class="sd">    :ivar single_site_id: The string ID of the single site at which to check</span>
<span class="sd">        the allele frequency condition, see :meth:`Contig.add_single_site`.</span>
<span class="sd">    :vartype single_site_id: str</span>
<span class="sd">    :ivar population: The name of the population in which to check</span>
<span class="sd">        the allele frequency condition.</span>
<span class="sd">    :vartype population: str</span>
<span class="sd">    :ivar op: The comparison operator used for the allele frequency condition,</span>
<span class="sd">        one of `(&quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;)`.</span>
<span class="sd">    :vartype op: str</span>
<span class="sd">    :ivar allele_frequency: The allele frequency to compare against.</span>
<span class="sd">    :vartype op: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">single_site_id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">allele_frequency</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">op_types</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">op_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid conditioning op `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allele_frequency</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have 0 &lt;= allele_frequency &lt;= 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allele_frequency</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allele_frequency</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;allele_frequency </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">allele_frequency</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="s2">&quot;condition is always false.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&gt;=&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allele_frequency</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&lt;=&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allele_frequency</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;allele_frequency </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">allele_frequency</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="s2">&quot;condition is always true.&quot;</span>
            <span class="p">)</span>
        <span class="n">validate_time_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">op_id</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>


<div class="viewcode-block" id="selective_sweep">
<a class="viewcode-back" href="../../api.html#stdpopsim.selective_sweep">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">selective_sweep</span><span class="p">(</span>
    <span class="n">single_site_id</span><span class="p">,</span>
    <span class="n">population</span><span class="p">,</span>
    <span class="n">mutation_generation_ago</span><span class="p">,</span>
    <span class="n">selection_coeff</span><span class="p">,</span>
    <span class="n">dominance_coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">start_generation_ago</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_generation_ago</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">min_freq_at_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">min_freq_at_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">globally_adaptive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a list of extended events corresponding to a selective sweep at a</span>
<span class="sd">    single site (see :meth:`Contig.add_single_site`) that may subsequently be</span>
<span class="sd">    passed to the simulation engine. The sequence of events is:</span>

<span class="sd">        (1) In generation `mutation_generation_ago`, a **neutral** mutation is</span>
<span class="sd">            introduced into `population`.</span>

<span class="sd">        (2) In generation `start_generation_ago`, the mutation becomes</span>
<span class="sd">            beneficial (whether globally or locally is controlled by the</span>
<span class="sd">            `globally_adaptive` option). If the frequency of the mutation in</span>
<span class="sd">            `population` is below `min_freq_at_start` in this generation, the</span>
<span class="sd">            simulation will restart from `mutation_generation_ago`.</span>

<span class="sd">        (3) In the generation after `end_generation_ago`, the mutation reverts to</span>
<span class="sd">            neutrality in `population`. If the frequency of the mutation in</span>
<span class="sd">            `population` is below `min_freq_at_end` in this generation, the</span>
<span class="sd">            simulation will restart from `mutation_generation_ago`.</span>

<span class="sd">    During the sweep, the fitnesses of individuals that are homozygous or</span>
<span class="sd">    heterozygous for the beneficial mutation are `1 + selection_coeff` and  `1</span>
<span class="sd">    + selection_coeff * dominance_coeff`, respectively. If `globally_adaptive`</span>
<span class="sd">    is `True` (the default), then all individuals carrying the mutation are</span>
<span class="sd">    impacted regardless of the population they belong to. Otherwise, the</span>
<span class="sd">    mutation only influences fitness within `population`.</span>

<span class="sd">    If the mutation is lost in `population` at any point between</span>
<span class="sd">    `mutation_generation_ago` and `end_generation_ago`, then the simulation</span>
<span class="sd">    will restart from `mutation_generation_ago`. The effect of &quot;restarting&quot;</span>
<span class="sd">    (aka &quot;rejection sampling&quot;) is that the resulting simulations are</span>
<span class="sd">    conditioned on the mutation being extant after time</span>
<span class="sd">    `mutation_generation_ago` with frequency above `min_freq_at_start` at</span>
<span class="sd">    `start_generation_ago` and `min_freq_at_end` at `end_generation_ago`.</span>

<span class="sd">    Because the simulation will restart until the allele frequency conditions</span>
<span class="sd">    are satisfied, care must be taken to ensure that these are reasonable. For</span>
<span class="sd">    example, if `start_generation_ago` is very close to</span>
<span class="sd">    `mutation_generation_ago` and `min_freq_at_start` is substantially greater</span>
<span class="sd">    than zero, the vast majority of proposed allele frequency trajectories will</span>
<span class="sd">    be rejected and the simulation may take an infeasibly long time to</span>
<span class="sd">    complete.</span>

<span class="sd">    :param str single_site_id: The string ID of the single site at which to introduce</span>
<span class="sd">        the mutation, see :meth:`Contig.add_single_site`.</span>
<span class="sd">    :param int population: The name of the population in which the mutation is</span>
<span class="sd">        introduced and the sweep occurs.</span>
<span class="sd">    :param float mutation_generation_ago: The number of generations in the past at which</span>
<span class="sd">        to introduce the mutation.</span>
<span class="sd">    :param float selection_coeff: The selection coefficient of the beneficial</span>
<span class="sd">        mutation during the sweep.  Must be greater than or equal to zero.</span>
<span class="sd">    :param float dominance_coeff: The dominance coefficient of the beneficial</span>
<span class="sd">        mutation during the sweep.  Defaults to `0.5`.</span>
<span class="sd">    :param float start_generation_ago: The number of generations in the past at which the</span>
<span class="sd">        sweep starts and the mutation switches from neutral to beneficial. Defaults to</span>
<span class="sd">        `mutation_generation_ago` (i.e. a &quot;hard&quot; sweep).</span>
<span class="sd">    :param float end_generation_ago: The number of generations in the past at which the</span>
<span class="sd">        sweep ends and the mutation switches from beneficial to neutral. Defaults to</span>
<span class="sd">        `0` (i.e. the end of the simulation).</span>
<span class="sd">    :param float min_freq_at_start: The minimum allowed frequency for the</span>
<span class="sd">        mutation in `population` at the start of the sweep (optional).</span>
<span class="sd">    :param float min_freq_at_end: The minimum allowed frequency for the</span>
<span class="sd">        mutation in `population` at the end of the sweep (optional).</span>
<span class="sd">    :param bool globally_adaptive: If `True` (default), the mutation is beneficial in all</span>
<span class="sd">        populations. If `False`, the mutation is beneficial only in the population of</span>
<span class="sd">        origin.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">start_generation_ago</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_generation_ago</span> <span class="o">=</span> <span class="n">mutation_generation_ago</span>
    <span class="k">if</span> <span class="n">end_generation_ago</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end_generation_ago</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">validate_time_range</span><span class="p">(</span><span class="n">mutation_generation_ago</span><span class="p">,</span> <span class="n">start_generation_ago</span><span class="p">)</span>
    <span class="n">validate_time_range</span><span class="p">(</span><span class="n">start_generation_ago</span><span class="p">,</span> <span class="n">end_generation_ago</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">selection_coeff</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Selection coefficient must be non-negative.&quot;</span><span class="p">)</span>

    <span class="n">extended_events</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">DrawMutation</span><span class="p">(</span>
            <span class="n">single_site_id</span><span class="o">=</span><span class="n">single_site_id</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">mutation_generation_ago</span><span class="p">,</span>
            <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">ConditionOnAlleleFrequency</span><span class="p">(</span>
            <span class="n">single_site_id</span><span class="o">=</span><span class="n">single_site_id</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">GenerationAfter</span><span class="p">(</span><span class="n">mutation_generation_ago</span><span class="p">),</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">end_generation_ago</span><span class="p">,</span>
            <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
            <span class="n">allele_frequency</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">op</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="c1"># Sweep period is [start_generation_ago, end_generation_ago] (endpoints inclusive).</span>
    <span class="n">sweep_restricted_to</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">globally_adaptive</span> <span class="k">else</span> <span class="n">population</span>
    <span class="n">extended_events</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">ChangeMutationFitness</span><span class="p">(</span>
                <span class="n">single_site_id</span><span class="o">=</span><span class="n">single_site_id</span><span class="p">,</span>
                <span class="n">start_time</span><span class="o">=</span><span class="n">start_generation_ago</span><span class="p">,</span>
                <span class="n">end_time</span><span class="o">=</span><span class="n">end_generation_ago</span><span class="p">,</span>
                <span class="n">population</span><span class="o">=</span><span class="n">sweep_restricted_to</span><span class="p">,</span>
                <span class="n">selection_coeff</span><span class="o">=</span><span class="n">selection_coeff</span><span class="p">,</span>
                <span class="n">dominance_coeff</span><span class="o">=</span><span class="n">dominance_coeff</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Only check sweep AF conditions in start/end generations, so that allele</span>
    <span class="c1"># trajectories are otherwise unconstrained.</span>
    <span class="k">if</span> <span class="n">min_freq_at_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">min_freq_at_start</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If specified, the minimum allele frequency at the start of the sweep &quot;</span>
                <span class="s2">&quot;must be in (0, 1].&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">start_generation_ago</span> <span class="o">==</span> <span class="n">mutation_generation_ago</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If the start time of the sweep coincides with the introduction &quot;</span>
                <span class="s2">&quot;of the mutation, then `min_freq_at_start` cannot be set.&quot;</span>
            <span class="p">)</span>
        <span class="n">extended_events</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">ConditionOnAlleleFrequency</span><span class="p">(</span>
                    <span class="n">single_site_id</span><span class="o">=</span><span class="n">single_site_id</span><span class="p">,</span>
                    <span class="n">start_time</span><span class="o">=</span><span class="n">start_generation_ago</span><span class="p">,</span>
                    <span class="n">end_time</span><span class="o">=</span><span class="n">start_generation_ago</span><span class="p">,</span>
                    <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                    <span class="n">allele_frequency</span><span class="o">=</span><span class="n">min_freq_at_start</span><span class="p">,</span>
                    <span class="n">op</span><span class="o">=</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">min_freq_at_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">min_freq_at_end</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If specified, the minimum allele frequency at the end of the sweep &quot;</span>
                <span class="s2">&quot;must be in (0, 1].&quot;</span>
            <span class="p">)</span>
        <span class="n">extended_events</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">ConditionOnAlleleFrequency</span><span class="p">(</span>
                    <span class="n">single_site_id</span><span class="o">=</span><span class="n">single_site_id</span><span class="p">,</span>
                    <span class="n">start_time</span><span class="o">=</span><span class="n">end_generation_ago</span><span class="p">,</span>
                    <span class="n">end_time</span><span class="o">=</span><span class="n">end_generation_ago</span><span class="p">,</span>
                    <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                    <span class="n">allele_frequency</span><span class="o">=</span><span class="n">min_freq_at_end</span><span class="p">,</span>
                    <span class="n">op</span><span class="o">=</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">extended_events</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">selection_coeff_from_mutation</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">mutation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the selection coefficient of the given mutation.</span>

<span class="sd">    In nearly all cases, this will just be &quot;the selection coefficient&quot; and</span>
<span class="sd">    users do not need to worry about the details. However: mutations produced</span>
<span class="sd">    by the SLiM engine have metadata which includes each mutation&#39;s selection</span>
<span class="sd">    coefficient. However, mutations may &quot;stack&quot;, meaning that one</span>
<span class="sd">    mutation-in-the-tree-sequence may in fact represent a superposition of</span>
<span class="sd">    several SLiM-produced-mutations. This method adds up all selection</span>
<span class="sd">    coefficients in the metadata of this mutation, and subtracts the sum of the</span>
<span class="sd">    selection coefficients of the parent mutation, if there is one. For more</span>
<span class="sd">    information, see the SLiM manual and `the pyslim manual</span>
<span class="sd">    &lt;https://tskit.dev/pyslim/docs/stable/tutorial.html#extracting-information-about-selected-mutations&gt;`__.</span>

<span class="sd">    :param ts: A ``tskit.TreeSequence`` containing the mutation.</span>
<span class="sd">    :param mutation: A ``tskit.Mutation`` for which to extract the selection coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`ts` must be a `tskit.TreeSequence` object&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mutation</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">Mutation</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`mutation` must be a `tskit.Mutation` object&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mutation</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="n">selection_coeff</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;selection_coeff&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mutation</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;mutation_list&quot;</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">mutation</span><span class="o">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">mutation</span><span class="p">(</span><span class="n">mutation</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">selection_coeff</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;selection_coeff&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;mutation_list&quot;</span><span class="p">]]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">selection_coeff</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2025, PopSim Consortium.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
     
    <div class="footer">Version: 0.2 (0.2.1a2.dev72+g8110013)</div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>