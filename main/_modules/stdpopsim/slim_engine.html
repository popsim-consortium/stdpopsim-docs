

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>stdpopsim.slim_engine &mdash; stdpopsim 0.2.1a2.dev85+gb410acf documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=dc93f7aa" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=e88f40ab"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            stdpopsim
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../catalog.html">Catalog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli_arguments.html">Command-line options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelogs.html">Changelogs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">stdpopsim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">stdpopsim.slim_engine</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for stdpopsim.slim_engine</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SLiM simulation engine.</span>

<span class="sd">This is a translation of the msprime API into SLiM&#39;s Eidos language, which</span>
<span class="sd">resembles R. The generated SLiM script is designed differently to the recipes</span>
<span class="sd">described in the SLiM reference manual. In our generated SLiM script, all the</span>
<span class="sd">demographic model parameters are defined in multi-dimensional arrays at the</span>
<span class="sd">top of the script, in the `initialize()` block. These arrays define the event</span>
<span class="sd">generations, and event blocks are subsequently constructed programmatically</span>
<span class="sd">using `community.registerLateEvent()`, rather than writing out the blocks verbatim.</span>
<span class="sd">This design is intended to permit modification of demographic parameters in</span>
<span class="sd">the generated SLiM script, without needing to directly convert event times in</span>
<span class="sd">the past into forwards-time generations.</span>

<span class="sd">How backwards-time demographic events are mapped to forwards-time SLiM code:</span>

<span class="sd"> * `msprime.DemographyDebugger()` does much of the hard work by extracting</span>
<span class="sd">   epochs from the given model&#39;s `demographic_events`, and calculating a</span>
<span class="sd">   migration_matrix for each epoch from the `msprime.MigrationRateChange`</span>
<span class="sd">   events. The epoch boundaries defined here are indirectly translated into</span>
<span class="sd">   &quot;late events&quot; in SLiM.</span>

<span class="sd"> * `msprime.PopulationParametersChange` events are translated into SLiM as</span>
<span class="sd">   `pop.setSubpopulationSize()`. If `growth_rate` is not None, the population</span>
<span class="sd">   size is changed in every generation to match the specified rate.</span>

<span class="sd"> * `msprime.MassMigration` events with proportion=1 are population splits</span>
<span class="sd">   in forwards time. In SLiM, these are `sim.addSubpopSplit()`.</span>

<span class="sd"> * `msprime.MassMigration` events with proportion&lt;1 indicate an admixture</span>
<span class="sd">   pulse at a single point in time. In SLiM, we call `pop.setMigrationRates()`</span>
<span class="sd">   in the relevant generation, and turn off migrations in the next generation.</span>
<span class="sd">   When multiple MassMigration events correspond to a single SLiM generation,</span>
<span class="sd">   the migration proportions multiply, following the msprime behaviour and</span>
<span class="sd">   event ordering.</span>

<span class="sd"> * The migration_matrix for each epoch describes continuous migrations that</span>
<span class="sd">   occur over long time periods. In SLiM, we call `pop.setMigrationRates()`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">string</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">subprocess</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">textwrap</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">stdpopsim</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">msprime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyslim</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_escape_eidos</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># this is for Windows paths passed as strings in Eidos</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">))</span>


<span class="n">_slim_upper</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">initialize() {</span>
<span class="s2">    if (!exists(&quot;dry_run&quot;))</span>
<span class="s2">        defineConstant(&quot;dry_run&quot;, F);</span>
<span class="s2">    if (!exists(&quot;verbosity&quot;))</span>
<span class="s2">        defineConstant(&quot;verbosity&quot;, 2);</span>

<span class="s2">    // Scaling factor to speed up simulation.</span>
<span class="s2">    // See SLiM manual:</span>
<span class="s2">    // `5.5 Rescaling population sizes to improve simulation performance`.</span>
<span class="s2">    defineConstant(&quot;Q&quot;, $scaling_factor);</span>

<span class="s2">    defineConstant(&quot;burn_in&quot;, $burn_in);</span>
<span class="s2">    defineConstant(&quot;generation_time&quot;, $generation_time);</span>
<span class="s2">    defineConstant(&quot;trees_file&quot;, &quot;$trees_file&quot;);</span>
<span class="s2">    defineConstant(&quot;pop_names&quot;, $pop_names);</span>

<span class="s2">    _recombination_rates = $recombination_rates;</span>
<span class="s2">    if (Q != 1) {</span>
<span class="s2">        _recombination_rates = (1-(1-2*_recombination_rates)^Q)/2;</span>
<span class="s2">    }</span>
<span class="s2">    _recombination_ends = $recombination_ends;</span>
<span class="s2">    defineConstant(&quot;recombination_rates&quot;, _recombination_rates);</span>
<span class="s2">    defineConstant(&quot;recombination_ends&quot;, _recombination_ends);</span>
<span class="s2">    // whatever is in this dictionary will be saved out in the .trees file</span>
<span class="s2">    defineConstant(&quot;metadata&quot;, Dictionary(&quot;Q&quot;, Q));</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="n">_slim_lower</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    // Note: these are floats because rounding causes error in population</span>
<span class="s2">    // growth: exp(round(x)*r*t) != round(exp(x*r*t))</span>
<span class="s2">    defineConstant(&quot;N&quot;, _N/Q);</span>

<span class="s2">    initializeTreeSeq(timeUnit=&quot;generations&quot;);</span>
<span class="s2">    initializeRecombinationRate(recombination_rates, recombination_ends);</span>
<span class="s2">}</span>

<span class="s2">function (void)err(string$ s) {</span>
<span class="s2">    stop(&quot;ERROR: &quot; + s);</span>
<span class="s2">}</span>

<span class="s2">function (void)warn(string$ s) {</span>
<span class="s2">    catn(&quot;WARNING: &quot; + s);</span>
<span class="s2">}</span>

<span class="s2">function (void)dbg(string$ s, [integer$ debug_level = 2]) {</span>
<span class="s2">    if (verbosity &gt;= debug_level) {</span>
<span class="s2">        catn(community.tick + &quot;: &quot; + s);</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="n">_slim_functions</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">// Check that sizes aren&#39;t dangerously low or zero (e.g. due to scaling).</span>
<span class="s2">function (void)check_size(integer$ pop, integer$ size, integer$ t) {</span>
<span class="s2">    if (size == 0) {</span>
<span class="s2">        err(&quot;The population size of p&quot;+pop+&quot; (&quot;+pop_names[pop]+&quot;) is zero &quot; +</span>
<span class="s2">            &quot;at tick &quot;+t+&quot;.&quot;);</span>
<span class="s2">    } else if (size &lt; 50) {</span>
<span class="s2">        warn(&quot;p&quot;+pop+&quot; (&quot;+pop_names[pop]+&quot;) has only &quot;+size+&quot; individuals &quot; +</span>
<span class="s2">             &quot;alive at tick &quot;+t+&quot;.&quot;);</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">// Return the epoch index for generation g.</span>
<span class="s2">function (integer)epoch(integer G, integer $g) {</span>
<span class="s2">    for (i in 0:(num_epochs-1)) {</span>
<span class="s2">        if (g &lt; G[i]) {</span>
<span class="s2">            return i;</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    return num_epochs - 1;</span>
<span class="s2">}</span>

<span class="s2">// Return the population size of pop at generation g.</span>
<span class="s2">// This function returns values consistent with the continuous-time</span>
<span class="s2">// msprime model, not taking into account discretization effects.</span>
<span class="s2">function (integer)pop_size_at(integer G, integer$ pop, integer$ g) {</span>
<span class="s2">    e = epoch(G, g);</span>
<span class="s2">    N0 = N[e,pop];</span>
<span class="s2">    r = Q * growth_rates[e,pop];</span>
<span class="s2">    if (r == 0) {</span>
<span class="s2">        N_g = N0;</span>
<span class="s2">    } else {</span>
<span class="s2">        g_diff = g - G[e-1];</span>
<span class="s2">        N_g = N0*exp(r*g_diff);</span>
<span class="s2">    }</span>
<span class="s2">    return asInteger(round(N_g));</span>
<span class="s2">}</span>

<span class="s2">// Return the tick number for a given number of years ago.</span>
<span class="s2">function (integer)time_to_tick(numeric t) {</span>
<span class="s2">    return G0 - asInteger(t/generation_time/Q);</span>
<span class="s2">}</span>

<span class="s2">// Output tree sequence file and end the simulation.</span>
<span class="s2">function (void)end(void) {</span>
<span class="s2">    sim.treeSeqOutput(trees_file, metadata=metadata);</span>
<span class="s2">    sim.simulationFinished();</span>
<span class="s2">}</span>


<span class="s2">// Add `mut_type` mutation at `pos`, to a single individual in `pop`.</span>
<span class="s2">function (void)add_mut(object$ mut_type, object$ pop, integer$ pos) {</span>
<span class="s2">   targets = sample(pop.genomes, 1);</span>
<span class="s2">   targets.addNewDrawnMutation(mut_type, pos);</span>
<span class="s2">}</span>

<span class="s2">// Return the allele frequency of a drawn mutation in the specified population.</span>
<span class="s2">// Assumes there&#39;s only one mutation of the given type.</span>
<span class="s2">function (float$)af(object$ mut_type, object$ pop) {</span>
<span class="s2">    mut = sim.mutationsOfType(mut_type);</span>
<span class="s2">    if (length(mut) == 0) {</span>
<span class="s2">        return 0.0;</span>
<span class="s2">    }</span>
<span class="s2">    return sim.mutationFrequencies(pop, mut);</span>
<span class="s2">}</span>

<span class="s2">// Save the state of the simulation.</span>
<span class="s2">function (void)save(void) {</span>
<span class="s2">    if (sim.getValue(&quot;restore_function&quot;)) {</span>
<span class="s2">        // Don&#39;t save if we&#39;re in the restore() function.</span>
<span class="s2">        return;</span>
<span class="s2">    }</span>
<span class="s2">    n_saves = 1 + sim.getValue(&quot;n_saves&quot;);</span>
<span class="s2">    sim.setValue(&quot;n_saves&quot;, n_saves);</span>
<span class="s2">    dbg(&quot;save() &quot;+n_saves);</span>
<span class="s2">    sim.treeSeqOutput(trees_file, metadata=metadata);</span>
<span class="s2">}</span>

<span class="s2">// Restore the simulation state.</span>
<span class="s2">function (void)restore(void) {</span>
<span class="s2">    g_restore = community.tick;</span>
<span class="s2">    n_restores = 1 + sim.getValue(&quot;n_restores&quot;);</span>
<span class="s2">    sim.setValue(&quot;n_restores&quot;, n_restores);</span>
<span class="s2">    n_saves = sim.getValue(&quot;n_saves&quot;);</span>
<span class="s2">    if (n_saves == 0) {</span>
<span class="s2">        err(&quot;restore() in tick &quot;+g_restore+&quot;, but nothing is saved.&quot;);</span>
<span class="s2">    }</span>
<span class="s2">    sim.readFromPopulationFile(trees_file);</span>
<span class="s2">    dbg(&quot;restore() &quot;+n_restores+&quot; from tick &quot;+g_restore+&quot;, returning &quot;+</span>
<span class="s2">        &quot;to state at save() &quot;+n_saves);</span>

<span class="s2">    /*</span>
<span class="s2">     * The tick counter community.tick has now been reset to the</span>
<span class="s2">     * value it had when save() was called. There are two issues relating</span>
<span class="s2">     * to event scheduling which must now be dealt with.</span>
<span class="s2">     *</span>
<span class="s2">     * 1. There may be additional late events for the tick in which</span>
<span class="s2">     * restore() was called, and they are still scheduled to run.</span>
<span class="s2">     * So we deactivate all script blocks in the &quot;late&quot; cycle to avoid</span>
<span class="s2">     * unexpected problems. They will be automatically reactivated at the</span>
<span class="s2">     * start of the next tick.</span>
<span class="s2">     */</span>
<span class="s2">    sb = community.allScriptBlocks;</span>
<span class="s2">    sb[sb.type == &quot;late&quot;].active = 0;</span>

<span class="s2">    /*</span>
<span class="s2">     * 2. The late events below were run in the save() tick,</span>
<span class="s2">     * but after the save() call. We execute these again here, because</span>
<span class="s2">     * the next late events to run will be for community.tick + 1.</span>
<span class="s2">     * Note that the save() event is indistinguishable from the other</span>
<span class="s2">     * late events in this tick, so we set a flag `restore_function`</span>
<span class="s2">     * to signal the save() function not to save again.</span>
<span class="s2">     */</span>
<span class="s2">    g = community.tick;</span>
<span class="s2">    sim.setValue(&quot;restore_function&quot;, T);</span>
<span class="s2">    for (sb in community.allScriptBlocks) {</span>
<span class="s2">        if (sb.type == &quot;late&quot; &amp; g &gt;= sb.start &amp; g &lt;= sb.end) {</span>
<span class="s2">            self = sb;</span>
<span class="s2">            executeLambda(sb.source);</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    sim.setValue(&quot;restore_function&quot;, F);</span>
<span class="s2">}</span>

<span class="s2">&quot;&quot;&quot;</span>


<span class="n">_slim_main</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">1 early() {</span>
<span class="s2">    // save/restore bookkeeping</span>
<span class="s2">    sim.setValue(&quot;n_restores&quot;, 0);</span>
<span class="s2">    sim.setValue(&quot;n_saves&quot;, 0);</span>
<span class="s2">    sim.setValue(&quot;restore_function&quot;, F);</span>

<span class="s2">    /*</span>
<span class="s2">     * Create initial populations and migration rates.</span>
<span class="s2">     */</span>

<span class="s2">    // Initial populations.</span>
<span class="s2">    for (i in 0:(num_populations-1)) {</span>
<span class="s2">        if (N[0,i] &gt; 0) {</span>
<span class="s2">            check_size(i, asInteger(round(N[0,i])), community.tick);</span>
<span class="s2">            dbg(&quot;p = sim.addSubpop(&quot;+i+&quot;, &quot;+asInteger(round(N[0,i]))+&quot;);&quot;);</span>
<span class="s2">            p = sim.addSubpop(i, asInteger(round(N[0,i])));</span>
<span class="s2">            dbg(&quot;p.name = &#39;&quot;+pop_names[i]+&quot;&#39;;&quot;);</span>
<span class="s2">            p.name = pop_names[i];</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    if (length(sim.subpopulations) == 0) {</span>
<span class="s2">        err(&quot;No populations with non-zero size in tick 1.&quot;);</span>
<span class="s2">    }</span>

<span class="s2">    // Initial migration rates.</span>
<span class="s2">    i = 0;</span>
<span class="s2">    for (j in 0:(num_populations-1)) {</span>
<span class="s2">        for (k in 0:(num_populations-1)) {</span>
<span class="s2">            if (j==k | N[i,j] &lt; 1 | N[i,k] &lt; 1) {</span>
<span class="s2">                next;</span>
<span class="s2">            }</span>

<span class="s2">            m = Q * migration_matrices[k,j,i];</span>
<span class="s2">            p = sim.subpopulations[j];</span>
<span class="s2">            dbg(&quot;p&quot;+j+&quot;.setMigrationRates(&quot;+k+&quot;, &quot;+m+&quot;);&quot;);</span>
<span class="s2">            p.setMigrationRates(k, m);</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    // The end of the burn-in is the starting tick, and corresponds to</span>
<span class="s2">    // tick G_start. All remaining events are relative to this tick.</span>
<span class="s2">    N_max = asInteger(round(max(N[0,0:(num_populations-1)])));</span>
<span class="s2">    G_start = 1 + asInteger(round(burn_in * N_max));</span>
<span class="s2">    defineConstant(&quot;G0&quot;, asInteger(max(_T) / generation_time / Q + G_start));</span>
<span class="s2">    G = time_to_tick(_T);</span>
<span class="s2">    G_end = max(G);</span>

<span class="s2">    /*</span>
<span class="s2">     * Register events occurring at time T_start or more recently.</span>
<span class="s2">     */</span>

<span class="s2">    // Save/restore events. These should come before all other events.</span>
<span class="s2">    if (length(drawn_mutations) &gt; 0) {</span>
<span class="s2">        n_checkpoints = 0;</span>
<span class="s2">        for (i in 0:(ncol(drawn_mutations)-1)) {</span>
<span class="s2">            save = drawn_mutations[4,i] == 1;</span>
<span class="s2">            if (save) {</span>
<span class="s2">                // Saving the state at more than one timepoint can can cause</span>
<span class="s2">                // incorrect conditioning in the rejection samples.</span>
<span class="s2">                if (n_checkpoints &gt; 0) {</span>
<span class="s2">                    err(&quot;Attempt to save state at more than one checkpoint&quot;);</span>
<span class="s2">                }</span>
<span class="s2">                n_checkpoints = n_checkpoints + 1;</span>

<span class="s2">                // Unconditionally save the state before the mutation is drawn.</span>
<span class="s2">                g = time_to_tick(drawn_mutations[0,i]);</span>
<span class="s2">                community.registerLateEvent(NULL, &quot;{save();}&quot;, g, g);</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    if (length(condition_on_allele_frequency) &gt; 0) {</span>
<span class="s2">        for (i in 0:(ncol(condition_on_allele_frequency)-1)) {</span>
<span class="s2">            g_start = time_to_tick(condition_on_allele_frequency[0,i]);</span>
<span class="s2">            g_end = time_to_tick(condition_on_allele_frequency[1,i]);</span>
<span class="s2">            mut_type = asInteger(condition_on_allele_frequency[2,i]);</span>
<span class="s2">            pop_id = asInteger(condition_on_allele_frequency[3,i]);</span>
<span class="s2">            op = op_types[asInteger(drop(condition_on_allele_frequency[4,i]))];</span>
<span class="s2">            af = condition_on_allele_frequency[5,i];</span>

<span class="s2">            if (g_start &gt; g_end) {</span>
<span class="s2">                err(&quot;Attempt to register AF conditioning callback with g_start=&quot;+</span>
<span class="s2">                    g_start+&quot; &gt; g_end=&quot;+g_end);</span>
<span class="s2">            }</span>

<span class="s2">            // Restore state if AF condition not met.</span>
<span class="s2">            community.registerLateEvent(NULL,</span>
<span class="s2">                &quot;{if (!(af(m&quot;+mut_type+&quot;, p&quot;+pop_id+&quot;) &quot;+op+&quot; &quot;+af+&quot;))&quot; +</span>
<span class="s2">                &quot; restore();}&quot;,</span>
<span class="s2">                g_start, g_end);</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    // Split events.</span>
<span class="s2">    if (length(subpopulation_splits) &gt; 0 ) {</span>
<span class="s2">        for (i in 0:(ncol(subpopulation_splits)-1)) {</span>
<span class="s2">            g = time_to_tick(subpopulation_splits[0,i]);</span>
<span class="s2">            newpop = asInteger(drop(subpopulation_splits[1,i]));</span>
<span class="s2">            size = asInteger(round(subpopulation_splits[2,i] / Q));</span>
<span class="s2">            oldpop = asInteger(subpopulation_splits[3,i]);</span>
<span class="s2">            check_size(newpop, size, g);</span>
<span class="s2">            community.registerLateEvent(NULL,</span>
<span class="s2">                &quot;{dbg(self.source); &quot; +</span>
<span class="s2">                &quot;p = sim.addSubpopSplit(&quot;+newpop+&quot;,&quot;+size+&quot;,&quot;+oldpop+&quot;); &quot; +</span>
<span class="s2">                &quot;p.name = &#39;&quot;+pop_names[newpop]+&quot;&#39;;}&quot;,</span>
<span class="s2">                g, g);</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    // Population size changes.</span>
<span class="s2">    if (num_epochs &gt; 1) {</span>
<span class="s2">        for (i in 1:(num_epochs-1)) {</span>
<span class="s2">            g = G[i-1];</span>
<span class="s2">            for (j in 0:(num_populations-1)) {</span>
<span class="s2">                // Change population size if this hasn&#39;t already been taken</span>
<span class="s2">                // care of by sim.addSubpop() or sim.addSubpopSplit().</span>
<span class="s2">                if ((N[i,j] != N[i-1,j] | growth_rates[i-1,j] != 0) &amp; N[i-1,j] &gt;= 1) {</span>
<span class="s2">                    check_size(j, asInteger(N[i,j]), g);</span>
<span class="s2">                    community.registerLateEvent(NULL,</span>
<span class="s2">                        &quot;{dbg(self.source); &quot; +</span>
<span class="s2">                        &quot;p&quot;+j+&quot;.setSubpopulationSize(&quot;+asInteger(round(N[i,j]))+&quot;);}&quot;,</span>
<span class="s2">                        g, g);</span>
<span class="s2">                }</span>

<span class="s2">                if (growth_rates[i,j] != 0) {</span>
<span class="s2">                    growth_phase_start = g+1;</span>
<span class="s2">                    growth_phase_end = G[i] - 1;</span>
<span class="s2">                    // this is the number of ticks that the pop will grow for</span>
<span class="s2">                    growth_phase_ticks = growth_phase_end - growth_phase_start;</span>
<span class="s2">                    // but this is the amount of continuous time the pop model grows for</span>
<span class="s2">                    growth_phase_length = growth_phase_ticks + 1;</span>

<span class="s2">                    if (growth_phase_start &gt;= growth_phase_end) {</span>
<span class="s2">                        // Demographic models could have duplicate epoch times,</span>
<span class="s2">                        // which should be fixed.</span>
<span class="s2">                        warn(&quot;growth_phase_start=&quot;+growth_phase_start+</span>
<span class="s2">                             &quot; &gt;= growth_phase_end=&quot;+growth_phase_end);</span>
<span class="s2">                        next;</span>
<span class="s2">                    }</span>

<span class="s2">                    N_growth_phase_end = pop_size_at(G, j, growth_phase_end);</span>
<span class="s2">                    check_size(j, N_growth_phase_end, growth_phase_end);</span>

<span class="s2">                    N0 = N[i,j];</span>
<span class="s2">                    r = Q * growth_rates[i,j] * growth_phase_length / growth_phase_ticks;</span>
<span class="s2">                    community.registerLateEvent(NULL,</span>
<span class="s2">                        &quot;{&quot; +</span>
<span class="s2">                            &quot;dbg(self.source); &quot; +</span>
<span class="s2">                            &quot;gx=community.tick-&quot;+g+&quot;; &quot; +</span>
<span class="s2">                            &quot;size=asInteger(round(&quot;+N0+&quot;*exp(&quot;+r+&quot;*gx))); &quot; +</span>
<span class="s2">                            &quot;p&quot;+j+&quot;.setSubpopulationSize(size);&quot; +</span>
<span class="s2">                        &quot;}&quot;,</span>
<span class="s2">                        growth_phase_start, growth_phase_end);</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }</span>

<span class="s2">        // Migration rates.</span>
<span class="s2">        for (i in 1:(num_epochs-1)) {</span>
<span class="s2">            for (j in 0:(num_populations-1)) {</span>
<span class="s2">                for (k in 0:(num_populations-1)) {</span>
<span class="s2">                    if (j==k | N[i,j] &lt; 1 | N[i,k] &lt; 1) {</span>
<span class="s2">                        next;</span>
<span class="s2">                    }</span>

<span class="s2">                    m_last = Q * migration_matrices[k,j,i-1];</span>
<span class="s2">                    m = Q * migration_matrices[k,j,i];</span>
<span class="s2">                    if (m == m_last) {</span>
<span class="s2">                        // Do nothing if the migration rate hasn&#39;t changed.</span>
<span class="s2">                        next;</span>
<span class="s2">                    }</span>
<span class="s2">                    g = G[i-1];</span>
<span class="s2">                    community.registerLateEvent(NULL,</span>
<span class="s2">                        &quot;{dbg(self.source); &quot; +</span>
<span class="s2">                        &quot;p&quot;+j+&quot;.setMigrationRates(&quot;+k+&quot;, &quot;+m+&quot;);}&quot;,</span>
<span class="s2">                        g, g);</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    // Admixture pulses.</span>
<span class="s2">    if (length(admixture_pulses) &gt; 0 ) {</span>
<span class="s2">        for (i in 0:(ncol(admixture_pulses)-1)) {</span>
<span class="s2">            g = time_to_tick(admixture_pulses[0,i]);</span>
<span class="s2">            dest = asInteger(admixture_pulses[1,i]);</span>
<span class="s2">            src = asInteger(admixture_pulses[2,i]);</span>
<span class="s2">            rate = admixture_pulses[3,i];</span>
<span class="s2">            community.registerLateEvent(NULL,</span>
<span class="s2">                &quot;{dbg(self.source); &quot; +</span>
<span class="s2">                &quot;p&quot;+dest+&quot;.setMigrationRates(&quot;+src+&quot;, &quot;+rate+&quot;);}&quot;,</span>
<span class="s2">                g, g);</span>
<span class="s2">            community.registerLateEvent(NULL,</span>
<span class="s2">                &quot;{dbg(self.source); &quot; +</span>
<span class="s2">                &quot;p&quot;+dest+&quot;.setMigrationRates(&quot;+src+&quot;, 0);}&quot;,</span>
<span class="s2">                g+1, g+1);</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    // Draw mutations.</span>
<span class="s2">    if (length(drawn_mutations) &gt; 0) {</span>
<span class="s2">        for (i in 0:(ncol(drawn_mutations)-1)) {</span>
<span class="s2">            g = time_to_tick(drawn_mutations[0,i]);</span>
<span class="s2">            mut_type = asInteger(drawn_mutations[1,i]);</span>
<span class="s2">            pop_id = asInteger(drawn_mutations[2,i]);</span>
<span class="s2">            coordinate = asInteger(drawn_mutations[3,i]);</span>
<span class="s2">            community.registerLateEvent(NULL,</span>
<span class="s2">                &quot;{dbg(self.source); &quot; +</span>
<span class="s2">                &quot;add_mut(m&quot;+mut_type+&quot;, p&quot;+pop_id+&quot;, &quot;+coordinate+&quot;);}&quot;,</span>
<span class="s2">                g, g);</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    // Setup fitness callbacks.</span>
<span class="s2">    if (length(fitness_callbacks) &gt; 0) {</span>
<span class="s2">        for (i in 0:(ncol(fitness_callbacks)-1)) {</span>
<span class="s2">            g_start = time_to_tick(fitness_callbacks[0,i]);</span>
<span class="s2">            g_end = time_to_tick(fitness_callbacks[1,i]);</span>
<span class="s2">            mut_type = asInteger(fitness_callbacks[2,i]);</span>
<span class="s2">            pop_id = asInteger(fitness_callbacks[3,i]);</span>
<span class="s2">            selection_coeff = Q * fitness_callbacks[4,i];</span>
<span class="s2">            dominance_coeff = fitness_callbacks[5,i];</span>

<span class="s2">            if (g_start &gt; g_end) {</span>
<span class="s2">                err(&quot;Attempt to register fitness callback with g_start=&quot;+</span>
<span class="s2">                    g_start+&quot; &gt; g_end=&quot;+g_end);</span>
<span class="s2">            }</span>

<span class="s2">            /* We explicitly format() here to prevent integral-valued floats</span>
<span class="s2">             * from getting converted to integers during string interpolation</span>
<span class="s2">             * (this triggers a type error when the fitness callback runs). */</span>
<span class="s2">            f_hom = format(&quot;</span><span class="si">%e</span><span class="s2">&quot;, 1 + selection_coeff);</span>
<span class="s2">            f_het = format(&quot;</span><span class="si">%e</span><span class="s2">&quot;, 1 + selection_coeff * dominance_coeff);</span>

<span class="s2">            /* &quot;All populations&quot; is encoded by a negative value of pop_id. */</span>
<span class="s2">            if (pop_id &lt; 0) {</span>
<span class="s2">                community.registerLateEvent(NULL,</span>
<span class="s2">                    &quot;{dbg(&#39;s=&quot;+selection_coeff+&quot;, h=&quot;+dominance_coeff+</span>
<span class="s2">                    &quot; for m&quot;+mut_type+&quot; globally&#39;);}&quot;,</span>
<span class="s2">                    g_start, g_start);</span>
<span class="s2">                community.registerLateEvent(NULL,</span>
<span class="s2">                    &quot;{dbg(&#39;s, h defaults for m&quot;+mut_type+&quot; globally&#39;);}&quot;,</span>
<span class="s2">                    g_end, g_end);</span>
<span class="s2">                sim.registerMutationEffectCallback(NULL,</span>
<span class="s2">                    &quot;{if (homozygous) return &quot;+f_hom+&quot;; else return &quot;+f_het+&quot;;}&quot;,</span>
<span class="s2">                    mut_type, NULL, g_start, g_end);</span>
<span class="s2">            } else {</span>
<span class="s2">                community.registerLateEvent(NULL,</span>
<span class="s2">                    &quot;{dbg(&#39;s=&quot;+selection_coeff+&quot;, h=&quot;+dominance_coeff+</span>
<span class="s2">                    &quot; for m&quot;+mut_type+&quot; in p&quot;+pop_id+&quot;&#39;);}&quot;,</span>
<span class="s2">                    g_start, g_start);</span>
<span class="s2">                community.registerLateEvent(NULL,</span>
<span class="s2">                    &quot;{dbg(&#39;s, h defaults for m&quot;+mut_type+&quot; in p&quot;+pop_id+&quot;&#39;);}&quot;,</span>
<span class="s2">                    g_end, g_end);</span>
<span class="s2">                sim.registerMutationEffectCallback(NULL,</span>
<span class="s2">                    &quot;{if (homozygous) return &quot;+f_hom+&quot;; else return &quot;+f_het+&quot;;}&quot;,</span>
<span class="s2">                    mut_type, pop_id, g_start, g_end);</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    // Setup mutation callbacks.</span>
<span class="s2">    // For each stdpopsim mutation type with an h-s relationship</span>
<span class="s2">    // we have a sequence of assigned SLiM mutation types;</span>
<span class="s2">    // the first is the one that gets produced by mutation,</span>
<span class="s2">    // and the remainder are assigned by a mutation callback.</span>
<span class="s2">    for (i in seqAlong(mut_types_with_callbacks)) {</span>
<span class="s2">        mt = mut_types_with_callbacks[i];</span>
<span class="s2">        sim.registerMutationCallback(NULL,</span>
<span class="s2">            &quot;{s = mut.selectionCoeff; &quot;</span>
<span class="s2">            + &quot;k = findInterval(s, dominance_coeff_breaks_&quot; + mt + &quot;); &quot;</span>
<span class="s2">            + &quot;mut.setMutationType(dominance_coeff_types_&quot; + mt + &quot;[k]); &quot;</span>
<span class="s2">            + &quot;return T;}&quot;,</span>
<span class="s2">            mt</span>
<span class="s2">        );</span>
<span class="s2">    }</span>

<span class="s2">    // Sample individuals.</span>
<span class="s2">    for (i in 0:(ncol(sampling_episodes)-1)) {</span>
<span class="s2">        pop = drop(asInteger(sampling_episodes[0,i]));</span>
<span class="s2">        n = sampling_episodes[1,i];</span>
<span class="s2">        g = time_to_tick(sampling_episodes[2,i]);</span>

<span class="s2">        // Check that there will be at least n individuals for sampling.</span>
<span class="s2">        N_g = pop_size_at(G, pop, g);</span>
<span class="s2">        if (n &gt; N_g) {</span>
<span class="s2">            err(&quot;Request to sample &quot;+n+&quot; individuals from p&quot;+pop+</span>
<span class="s2">                &quot; (&quot;+pop_names[pop]+&quot;) at tick &quot;+g+&quot;, but only &quot;+</span>
<span class="s2">                N_g+&quot; individuals will be alive.&quot;);</span>
<span class="s2">        }</span>

<span class="s2">        if (n &gt; 0) {</span>
<span class="s2">            community.registerLateEvent(NULL,</span>
<span class="s2">                &quot;{dbg(self.source); &quot; +</span>
<span class="s2">                &quot;inds=p&quot;+pop+&quot;.sampleIndividuals(&quot;+n+&quot;); &quot; +</span>
<span class="s2">                &quot;sim.treeSeqRememberIndividuals(inds);}&quot;,</span>
<span class="s2">                g, g);</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">    community.registerLateEvent(NULL, &quot;{dbg(self.source); end();}&quot;, G_end, G_end);</span>

<span class="s2">    if (G_start &gt; community.tick) {</span>
<span class="s2">        dbg(&quot;Starting burn-in...&quot;);</span>
<span class="s2">    }</span>

<span class="s2">    if (dry_run) {</span>
<span class="s2">        sim.simulationFinished();</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_slim_logfile</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">// Optional logfile output:</span>
<span class="s2">// Fitness values are only available in early(),</span>
<span class="s2">// so logging happens in that stage.</span>
<span class="s2">1 early () {</span>
<span class="s2">    defineConstant(&quot;log&quot;, community.createLogFile(&quot;$logfile&quot;, logInterval=NULL));</span>
<span class="s2">    log.addTick();</span>
<span class="s2">    log.precision = 12;</span>
<span class="s2">    for (pop in sim.subpopulations.id) {</span>
<span class="s2">        log.addMeanSDColumns(</span>
<span class="s2">            &quot;fitness_p&quot; + pop,</span>
<span class="s2">            &quot;p&quot; + pop + &quot;.cachedFitness(NULL);&quot;</span>
<span class="s2">        );</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">1: early() {</span>
<span class="s2">    if ((community.tick - 1) % $loginterval == 0)</span>
<span class="s2">        log.logRow();</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="n">_slim_debug_output</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">///</span>
<span class="s2">/// Debugging output</span>
<span class="s2">///</span>

<span class="s2">// Print out selection coefficients for every new mutation:</span>
<span class="s2">// this is for development purposes, and the format of this output</span>
<span class="s2">// is subject to change or may even be removed!</span>
<span class="s2">// Header:</span>
<span class="s2">1 late() {</span>
<span class="s2">    if (verbosity &gt;= 3) {</span>
<span class="s2">        dbg(paste(c(&quot;dbg_selection_coeff:&quot;,</span>
<span class="s2">                    &quot;selectionCoeff&quot;,</span>
<span class="s2">                    &quot;id&quot;,</span>
<span class="s2">                    &quot;position&quot;),</span>
<span class="s2">                  sep=&quot;</span><span class="se">\t</span><span class="s2">&quot;));</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">// Content:</span>
<span class="s2">1: late() {</span>
<span class="s2">    // Print out selection coefficients for every new mutation:</span>
<span class="s2">    // this is for development purposes, and the format of this output</span>
<span class="s2">    // is subject to change or may even be removed!</span>
<span class="s2">    if (verbosity &gt;= 3) {</span>
<span class="s2">        new = (sim.mutations.originTick == community.tick);</span>
<span class="s2">        for (mut in sim.mutations[new]) {</span>
<span class="s2">            dbg(paste(c(&quot;dbg_selection_coeff:&quot;,</span>
<span class="s2">                        mut.selectionCoeff,</span>
<span class="s2">                        mut.id,</span>
<span class="s2">                        mut.position),</span>
<span class="s2">                      sep=&quot;</span><span class="se">\t</span><span class="s2">&quot;));</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">// Save genomic element type information in tree sequence metadata</span>
<span class="s2">// This is for development purposes, and the format of this metadata</span>
<span class="s2">// is subject to change or may even be removed!</span>
<span class="s2">1 early() {</span>
<span class="s2">    if (verbosity &gt;= 3) {</span>
<span class="s2">        // recombination map</span>
<span class="s2">        metadata.setValue(</span>
<span class="s2">            &quot;recombination_rates&quot;,</span>
<span class="s2">            sim.chromosome.recombinationRates</span>
<span class="s2">        );</span>
<span class="s2">        metadata.setValue(</span>
<span class="s2">            &quot;recombination_ends&quot;,</span>
<span class="s2">            sim.chromosome.recombinationEndPositions</span>
<span class="s2">        );</span>
<span class="s2">        // mutationTypes</span>
<span class="s2">        muts = Dictionary();</span>
<span class="s2">        for (mt in sim.mutationTypes) {</span>
<span class="s2">            mut_info = Dictionary(</span>
<span class="s2">                &quot;distributionParams&quot;, mt.distributionParams,</span>
<span class="s2">                &quot;distributionType&quot;, mt.distributionType,</span>
<span class="s2">                &quot;dominanceCoeff&quot;, mt.dominanceCoeff</span>
<span class="s2">            );</span>
<span class="s2">            muts.setValue(asString(mt.id), mut_info);</span>
<span class="s2">        }</span>
<span class="s2">        metadata.setValue(&quot;mutationTypes&quot;, muts);</span>
<span class="s2">        // genomicElementTypes</span>
<span class="s2">        ge_starts = sim.chromosome.genomicElements.startPosition;</span>
<span class="s2">        ge_ends= sim.chromosome.genomicElements.endPosition;</span>
<span class="s2">        ge_types= sim.chromosome.genomicElements.genomicElementType.id;</span>
<span class="s2">        ges = Dictionary();</span>
<span class="s2">        for (gt in sim.genomicElementTypes) {</span>
<span class="s2">            gt_info = Dictionary(</span>
<span class="s2">                &quot;mutationTypes&quot;, gt.mutationTypes.id,</span>
<span class="s2">                &quot;mutationFractions&quot;, gt.mutationFractions,</span>
<span class="s2">                &quot;intervalStarts&quot;, ge_starts[ge_types == gt.id],</span>
<span class="s2">                &quot;intervalEnds&quot;, ge_ends[ge_types == gt.id]</span>
<span class="s2">            );</span>
<span class="s2">            ges.setValue(asString(gt.id), gt_info);</span>
<span class="s2">        }</span>
<span class="s2">        metadata.setValue(&quot;genomicElementTypes&quot;, ges);</span>
<span class="s2">        // mutation rates</span>
<span class="s2">        mr = Dictionary(</span>
<span class="s2">            &quot;rates&quot;, sim.chromosome.mutationRates,</span>
<span class="s2">            &quot;ends&quot;, sim.chromosome.mutationEndPositions</span>
<span class="s2">        );</span>
<span class="s2">        metadata.setValue(&quot;mutationRates&quot;, mr);</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">// Save populations size information in tree sequence metadata</span>
<span class="s2">// This is for development purposes, and the format of this metadata</span>
<span class="s2">// is subject to change or may even be removed!</span>
<span class="s2">1 first() {</span>
<span class="s2">    if (verbosity &gt;= 3) {</span>
<span class="s2">        metadata.setValue(&quot;population_sizes&quot;, Dictionary());</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">1: late() {</span>
<span class="s2">    if (verbosity &gt;= 3) {</span>
<span class="s2">        popsizes = metadata.getValue(&quot;population_sizes&quot;);</span>
<span class="s2">        for (pop in sim.subpopulations) {</span>
<span class="s2">            traj = popsizes.getValue(pop.name);</span>
<span class="s2">            if (isNULL(traj)) {</span>
<span class="s2">                traj = Dictionary();</span>
<span class="s2">                popsizes.setValue(pop.name, traj);</span>
<span class="s2">            }</span>
<span class="s2">            traj.setValue(&quot;t&quot;, c(traj.getValue(&quot;t&quot;), community.tick));</span>
<span class="s2">            traj.setValue(&quot;N&quot;, c(traj.getValue(&quot;N&quot;), pop.individualCount));</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_raw_stdpopsim_top_level_schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;stdpopsim&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Top-level metadata for a tree sequence produced by stdposim using the SLiM engine&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
        <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;DFEs&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
                <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">},</span>
                        <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">},</span>
                        <span class="s2">&quot;long_description&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">},</span>
                        <span class="s2">&quot;mutation_types&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
                                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
                                    <span class="s2">&quot;dominance_coeff&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;null&quot;</span><span class="p">]},</span>
                                    <span class="s2">&quot;dominance_coeff_list&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;null&quot;</span><span class="p">]},</span>
                                    <span class="s2">&quot;dominance_coeff_breaks&quot;</span><span class="p">:</span> <span class="p">{</span>
                                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;null&quot;</span><span class="p">]</span>
                                    <span class="p">},</span>
                                    <span class="s2">&quot;distribution_type&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">},</span>
                                    <span class="s2">&quot;distribution_args&quot;</span><span class="p">:</span> <span class="p">{</span>
                                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;string&quot;</span><span class="p">]},</span>
                                    <span class="p">},</span>
                                    <span class="s2">&quot;convert_to_substitution&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;boolean&quot;</span><span class="p">},</span>
                                    <span class="s2">&quot;Q_scaled_index&quot;</span><span class="p">:</span> <span class="p">{</span>
                                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">},</span>
                                    <span class="p">},</span>
                                    <span class="s2">&quot;slim_mutation_type_id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">},</span>
                                    <span class="s2">&quot;is_neutral&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;boolean&quot;</span><span class="p">},</span>
                                <span class="p">},</span>
                            <span class="p">},</span>
                        <span class="p">},</span>
                        <span class="s2">&quot;proportions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">}},</span>
                        <span class="s2">&quot;citations&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;object&quot;</span><span class="p">]},</span>
                        <span class="p">},</span>
                        <span class="s2">&quot;intervals&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;minItems&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;maxItems&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
                        <span class="p">},</span>
                        <span class="s2">&quot;start_time&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">},</span>
                        <span class="s2">&quot;end_time&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">},</span>
                    <span class="p">},</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_slim_mutation_rate_map</span><span class="p">(</span><span class="n">contig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple with the breakpoints and rates of mutations for SLiM.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">breaks</span><span class="p">,</span> <span class="n">dfe_labels</span> <span class="o">=</span> <span class="n">contig</span><span class="o">.</span><span class="n">dfe_breakpoints</span><span class="p">()</span>  <span class="c1"># beware -1 labels</span>
    <span class="n">slim_fractions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">p</span>
                    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">mt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">proportions</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">mutation_types</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">mt</span><span class="o">.</span><span class="n">is_neutral</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">contig</span><span class="o">.</span><span class="n">dfe_list</span>
        <span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># append 0 for the -1 labels</span>
    <span class="n">slim_rates</span> <span class="o">=</span> <span class="n">contig</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">*</span> <span class="n">slim_fractions</span><span class="p">[</span><span class="n">dfe_labels</span><span class="p">]</span>
    <span class="n">slim_breaks</span> <span class="o">=</span> <span class="n">breaks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># SLiM has inclusive right endpoints</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">slim_breaks</span><span class="p">,</span> <span class="n">slim_rates</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">slim_array_string</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">80</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format an array as a SLiM c() array and return as a line-wrapped string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="s2">&quot;c(</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="o">+</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)),</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">initial_indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span>
            <span class="n">subsequent_indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_enum_dfe_and_intervals</span><span class="p">(</span><span class="n">contig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an iterator which, for every `DFE` in the `contig`, returns a tuple</span>
<span class="sd">    containing a numeric id for said DFE, the DFE object and the list of</span>
<span class="sd">    intervals associated with the DFE. We need to assign each DFE a numeric id</span>
<span class="sd">    both in the slim_makescript and in the _add_dfes_to_metadata, so with this</span>
<span class="sd">    function we can ensure these two steps assigns numeric ids to the DFEs in the</span>
<span class="sd">    same way.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">dfe_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">interval_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ints</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">dfe_list</span><span class="p">,</span> <span class="n">contig</span><span class="o">.</span><span class="n">interval_list</span><span class="p">)):</span>
        <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ints</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dfe_to_mtypes</span><span class="p">(</span><span class="n">contig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns mutation type ids to each of the mutation types contained in this</span>
<span class="sd">    `Contig`. This function will return a dictionary with `len(contig.dfe_list)`</span>
<span class="sd">    elements, in which the position of the DFE in `contig.dfe_list` is the key.</span>
<span class="sd">    For each DFE, the dictionary holds a list of tuples that contain the</span>
<span class="sd">    assigned mutation type ids (used in SLiM) and the `MutationType` object.</span>
<span class="sd">    This is necessary so that we use the same numeric ids to the mutation types</span>
<span class="sd">    in the _add_dfes_to_metadata and slim_makescript steps.</span>

<span class="sd">    The assigned mutation type ids is stored as a tuple, that is only of length</span>
<span class="sd">    greater than one if the mutation type is of a sort that is implemented</span>
<span class="sd">    using more than one SLiM mutation type; currently, these are only mutation</span>
<span class="sd">    types with a discretized h-s relationship, and (a) only the first of these</span>
<span class="sd">    mutation types are actually assigned a positive mutation rate in SLiM, but</span>
<span class="sd">    (b) all mutations of the first type are transformed to the other mutation</span>
<span class="sd">    types in the list, and hence never end up in the final tree sequence. (See</span>
<span class="sd">    Recipe 10.6 in the SLiM manual, &quot;Varying the dominance coefficient among</span>
<span class="sd">    mutations&quot;.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dfe_to_mtypes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_enum_dfe_and_intervals</span><span class="p">(</span><span class="n">contig</span><span class="p">):</span>
        <span class="n">dfe_to_mtypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">mutation_types</span><span class="p">:</span>
            <span class="c1"># the first mutation type will be the one that has the mutation rate</span>
            <span class="c1"># and each new mutation gets converted to one of the *other* types;</span>
            <span class="n">mid_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mid</span><span class="p">]</span>
            <span class="n">mid</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">mt</span><span class="o">.</span><span class="n">dominance_coeff_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">dominance_coeff_list</span><span class="p">:</span>
                    <span class="n">mid_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span>
                    <span class="n">mid</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">dfe_to_mtypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mid_list</span><span class="p">),</span> <span class="n">mt</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dfe_to_mtypes</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_add_dfes_to_metadata</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">contig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the DFEs to the top-level metadata of a tree sequence using</span>
<span class="sd">    information in the `contig`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_json</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># recursively flattens an object to a dictionary.</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__dict__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">metadata</span>
    <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_raw_stdpopsim_top_level_schema</span><span class="p">)</span>
    <span class="n">dfes</span> <span class="o">=</span> <span class="n">_get_json</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">dfe_list</span><span class="p">)</span>
    <span class="n">dfe_to_mtypes</span> <span class="o">=</span> <span class="n">_dfe_to_mtypes</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ints</span> <span class="ow">in</span> <span class="n">_enum_dfe_and_intervals</span><span class="p">(</span><span class="n">contig</span><span class="p">):</span>
        <span class="n">dfes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;intervals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ints</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dfes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;proportions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">proportions</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">mid_list</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfe_to_mtypes</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">add</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;slim_mutation_type_id&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">mid_list</span><span class="p">),</span>
                <span class="s2">&quot;is_neutral&quot;</span><span class="p">:</span> <span class="n">mt</span><span class="o">.</span><span class="n">is_neutral</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">dfes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;mutation_types&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
    <span class="n">new_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stdpopsim&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DFEs&quot;</span><span class="p">:</span> <span class="n">dfes</span><span class="p">}}</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_metadata</span><span class="p">)</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
    <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">msprime_rm_to_slim_rm</span><span class="p">(</span><span class="n">recombination_map</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert recombination map from start position coords to end position coords.</span>

<span class="sd">    In SLiM, if ends[j-1] = a and ends[j] = b, then the recombination rate rates[j]</span>
<span class="sd">    applies to the links between a and b, i.e., to the links a:(a+1), (a+1):(a+2),</span>
<span class="sd">    ... (b-1):b. The tree sequence output by a SLiM simulation with L loci</span>
<span class="sd">    (i.e., positions 0, ..., L-1) will have sequence length equal to L, because</span>
<span class="sd">    intervals in tskit are open on the right, so the interval [0, L) does not</span>
<span class="sd">    include L.</span>

<span class="sd">    On the other hand, in msprime, a recombination rate map with some rate</span>
<span class="sd">    applied to the interval [x, y) will allow recombination events to the</span>
<span class="sd">    integers falling in [x, y); an event occuring at x will split x-1 from x,</span>
<span class="sd">    and so this implies recombination for the links from</span>
<span class="sd">    (x-1):x, x:(x+1), ..., (y-2):(y-1); this would correspond to ends of x-1</span>
<span class="sd">    and y-1 in SLiM.</span>

<span class="sd">    Note that this implies that the recombination rate that a msprime RateMap</span>
<span class="sd">    assigns to the interval [0, 1) has no effect in a discrete msprime</span>
<span class="sd">    simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">rate</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># replace missing values with 0 recombination rate</span>
    <span class="n">rates</span><span class="p">[</span><span class="n">recombination_map</span><span class="o">.</span><span class="n">missing</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">position</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rates</span><span class="p">,</span> <span class="n">ends</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">slim_makescript</span><span class="p">(</span>
    <span class="n">script_file</span><span class="p">,</span>
    <span class="n">trees_file</span><span class="p">,</span>
    <span class="n">demographic_model</span><span class="p">,</span>
    <span class="n">contig</span><span class="p">,</span>
    <span class="n">samples</span><span class="p">,</span>
    <span class="n">extended_events</span><span class="p">,</span>
    <span class="n">scaling_factor</span><span class="p">,</span>
    <span class="n">burn_in</span><span class="p">,</span>
    <span class="n">slim_rate_map</span><span class="p">,</span>
    <span class="n">logfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">logfile_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>

    <span class="n">pop_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
    <span class="c1"># Use copies of these so that the time frobbing below doesn&#39;t have</span>
    <span class="c1"># side-effects in the caller&#39;s model.</span>
    <span class="n">demographic_events</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">demographic_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extended_events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extended_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extended_events</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">extended_events</span><span class="p">)</span>

    <span class="c1"># Reassign event times according to integral SLiM ticks.</span>
    <span class="c1"># This collapses the time deltas used in HomSap/AmericanAdmixture_4B18,</span>
    <span class="c1"># and calculates times for GenerationAfter objects.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fix_time</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;start_time&quot;</span><span class="p">,</span> <span class="s2">&quot;end_time&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="n">t_rounded</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">scaling_factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">scaling_factor</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">GenerationAfter</span><span class="p">):</span>
                <span class="n">t_rounded</span> <span class="o">-=</span> <span class="n">scaling_factor</span>
            <span class="k">if</span> <span class="n">t_rounded</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bad </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">t_rounded</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">demographic_events</span><span class="p">:</span>
        <span class="n">fix_time</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">extended_events</span><span class="p">:</span>
        <span class="n">fix_time</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="c1"># The demography debugger constructs event epochs, which we use</span>
    <span class="c1"># to define the forwards-time events.</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">debug</span><span class="p">()</span>
    <span class="c1"># msprime.DemographyDebugger(</span>
    <span class="c1">#     population_configurations=demographic_model.population_configurations,</span>
    <span class="c1">#     migration_matrix=demographic_model.migration_matrix,</span>
    <span class="c1">#     demographic_events=demographic_events,</span>
    <span class="c1"># )</span>

    <span class="n">epochs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">epochs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">]</span>
    <span class="n">migration_matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">migration_matrix</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">]</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">num_populations</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">growth_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">num_populations</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
            <span class="c1"># SLiM simulates a diploid population, so rescale population size</span>
            <span class="c1"># depending on contig ploidy. If/when the SLiM simulation is</span>
            <span class="c1"># converted to a haploid model, this rescaling should be removed.</span>
            <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">end_size</span> <span class="o">*</span> <span class="n">contig</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">growth_rates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">growth_rate</span>

    <span class="n">admixture_pulses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">subpopulation_splits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">de</span> <span class="ow">in</span> <span class="n">epoch</span><span class="o">.</span><span class="n">demographic_events</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">de</span><span class="p">,</span> <span class="n">msprime</span><span class="o">.</span><span class="n">demography</span><span class="o">.</span><span class="n">LineageMovementEvent</span><span class="p">):</span>
                <span class="c1"># This is using internal msprime APIs here, but it&#39;s not worth</span>
                <span class="c1"># updating before we change over to Demes.</span>
                <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">de</span><span class="o">.</span><span class="n">_as_lineage_movements</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">lm</span><span class="o">.</span><span class="n">proportion</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Calculate remainder of population after previous</span>
                        <span class="c1"># MassMigration events in this epoch.</span>
                        <span class="n">rem</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">ap</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">admixture_pulses</span>
                                <span class="k">if</span> <span class="n">ap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">ap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">lm</span><span class="o">.</span><span class="n">source</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">admixture_pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="n">i</span><span class="p">,</span>
                                <span class="n">lm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>  <span class="c1"># forwards-time dest</span>
                                <span class="n">lm</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>  <span class="c1"># forwards-time source</span>
                                <span class="n">rem</span> <span class="o">*</span> <span class="n">lm</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1"># Backwards: lm.source is being merged into lm.dest.</span>
                    <span class="c1"># Forwards: lm.source is being created, taking individuals</span>
                    <span class="c1">#           from lm.dest.</span>
                    <span class="c1">#</span>
                    <span class="c1"># If the proportion==1, we can use SLiM function:</span>
                    <span class="c1">#       sim.addSubpopSplit(newpop, size, oldpop),</span>
                    <span class="c1"># which we trigger by adding a row to subpopulation_splits.</span>
                    <span class="c1"># This SLiM function creates newpop (=lm.source), under the</span>
                    <span class="c1"># assumption that it doesn&#39;t already exist.</span>

                    <span class="n">subpopulation_splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_T[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">lm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_N[</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">lm</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">lm</span><span class="o">.</span><span class="n">dest</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># Zero out the population size for ticks before this</span>
                    <span class="c1"># epoch, to avoid simulating invididuals that contribute no</span>
                    <span class="c1"># genealogy.</span>
                    <span class="n">N</span><span class="p">[</span><span class="n">lm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">growth_rates</span><span class="p">[</span><span class="n">lm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Ensure there are no migrations to or from lm.source before</span>
                    <span class="c1"># this epoch.</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">num_populations</span><span class="p">):</span>
                            <span class="n">migration_matrices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">lm</span><span class="o">.</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">migration_matrices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">lm</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">drawn_mutations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fitness_callbacks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">condition_on_allele_frequency</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">op_id</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">ConditionOnAlleleFrequency</span><span class="o">.</span><span class="n">op_id</span>
    <span class="n">slim_mutation_ids</span> <span class="o">=</span> <span class="n">_dfe_to_mtypes</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>
    <span class="n">drawn_single_site_ids</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">referenced_single_site_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">population_name_to_index</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">demographic_model</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">extended_events</span><span class="p">:</span>
        <span class="n">cls_name</span> <span class="o">=</span> <span class="n">ee</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">mutation_type_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">population_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="s2">&quot;single_site_id&quot;</span><span class="p">):</span>
            <span class="n">dfe_index</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">dfe_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfe_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The single site with id &#39;</span><span class="si">{</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;referenced by </span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> must exist and be uniquely &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;labelled, but there are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dfe_index</span><span class="p">)</span><span class="si">}</span><span class="s2"> DFEs &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;with this id on </span><span class="si">{</span><span class="n">contig</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="p">)</span>
            <span class="n">dfe_index</span> <span class="o">=</span> <span class="n">dfe_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slim_mutation_ids</span><span class="p">[</span><span class="n">dfe_index</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The single site with id &#39;</span><span class="si">{</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="si">}</span><span class="s2">&#39; referenced &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;by </span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> must contain a single mutation type, but &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">slim_mutation_ids</span><span class="p">[</span><span class="n">dfe_index</span><span class="p">])</span><span class="si">}</span><span class="s2"> mutation &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;types.&quot;</span>
                <span class="p">)</span>
            <span class="n">dfe_intervals</span> <span class="o">=</span> <span class="n">contig</span><span class="o">.</span><span class="n">interval_list</span><span class="p">[</span><span class="n">dfe_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dfe_intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The single site id &#39;</span><span class="si">{</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="si">}</span><span class="s2">&#39; referenced by &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> has no coordinate: it may have been removed &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;by the addition of an overlapping DFE after the single &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;site was added to the contig.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">dfe_intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="n">dfe_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dfe_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The id &#39;</span><span class="si">{</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="si">}</span><span class="s2">&#39; referenced by </span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;refers to a DFE with intervals </span><span class="si">{</span><span class="n">dfe_intervals</span><span class="si">}</span><span class="s2">, not &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to a single site.&quot;</span>
                <span class="p">)</span>
            <span class="n">mt_id_list</span><span class="p">,</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">slim_mutation_ids</span><span class="p">[</span><span class="n">dfe_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="o">.</span><span class="n">distribution_type</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The single site id &#39;</span><span class="si">{</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="si">}</span><span class="s2">&#39; referenced by &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> has a mutation type with fitness &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;distribution &#39;</span><span class="si">{</span><span class="n">mt</span><span class="o">.</span><span class="n">distribution_type</span><span class="si">}</span><span class="s2">&#39;, instead of a &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;fixed fitness coefficient.&quot;</span>
                <span class="p">)</span>
            <span class="n">coordinate</span> <span class="o">=</span> <span class="n">dfe_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">mutation_type_id</span> <span class="o">=</span> <span class="n">mt_id_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="s2">&quot;start_time&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="s2">&quot;end_time&quot;</span><span class="p">):</span>
            <span class="c1"># Now that GenerationAfter times have been accounted for, we can</span>
            <span class="c1"># properly catch invalid start/end times.</span>
            <span class="n">stdpopsim</span><span class="o">.</span><span class="n">validate_time_range</span><span class="p">(</span><span class="n">ee</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">ee</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="s2">&quot;population&quot;</span><span class="p">):</span>
            <span class="c1"># Convert population name to integer index. &quot;-1&quot; is used to encode</span>
            <span class="c1"># all populations (currently only valid for ChangeMutationFitness).</span>
            <span class="k">if</span> <span class="n">ee</span><span class="o">.</span><span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">population_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">ee</span><span class="o">.</span><span class="n">population</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">population_name_to_index</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The population </span><span class="si">{</span><span class="n">ee</span><span class="o">.</span><span class="n">population</span><span class="si">}</span><span class="s2"> referenced by &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> is not in demographic model &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">demographic_model</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">, with defined populations &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">population_name_to_index</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">population_id</span> <span class="o">=</span> <span class="n">population_name_to_index</span><span class="p">[</span><span class="n">ee</span><span class="o">.</span><span class="n">population</span><span class="p">]</span>

        <span class="c1"># Append attributes to lists per event type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">DrawMutation</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">population_id</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">drawn_mutations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">time</span> <span class="o">*</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">,</span>
                    <span class="n">mutation_type_id</span><span class="p">,</span>
                    <span class="n">population_id</span><span class="p">,</span>
                    <span class="n">coordinate</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>  <span class="c1"># flag to save state in mutation generation</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">drawn_single_site_ids</span><span class="p">[</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">ChangeMutationFitness</span><span class="p">):</span>
            <span class="n">fitness_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">,</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">end_time</span> <span class="o">*</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">,</span>
                    <span class="n">mutation_type_id</span><span class="p">,</span>
                    <span class="n">population_id</span><span class="p">,</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">selection_coeff</span><span class="p">,</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">dominance_coeff</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">referenced_single_site_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">ConditionOnAlleleFrequency</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">population_id</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">condition_on_allele_frequency</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">,</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">end_time</span> <span class="o">*</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">,</span>
                    <span class="n">mutation_type_id</span><span class="p">,</span>
                    <span class="n">population_id</span><span class="p">,</span>
                    <span class="n">op_id</span><span class="p">(</span><span class="n">ee</span><span class="o">.</span><span class="n">op</span><span class="p">),</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">allele_frequency</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">referenced_single_site_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown extended event type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ee</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Check that there exists only one drawn mutation per single site.</span>
    <span class="k">for</span> <span class="n">single_site_id</span><span class="p">,</span> <span class="n">n_drawn_mutations</span> <span class="ow">in</span> <span class="n">drawn_single_site_ids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">n_drawn_mutations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The single site </span><span class="si">{</span><span class="n">single_site_id</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="n">n_drawn_mutations</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mutations, but a maximum of one mutation is allowed per &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;single site.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Check that drawn mutations exist for extended events that need them.</span>
    <span class="k">for</span> <span class="n">single_site_id</span> <span class="ow">in</span> <span class="n">referenced_single_site_ids</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">single_site_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drawn_single_site_ids</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;An extended event requires a mutation at single site &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">single_site_id</span><span class="si">}</span><span class="s2">, but no mutation is drawn at this site.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Set &quot;save state&quot; flag for the oldest drawn mutation</span>
    <span class="n">drawn_mutations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">drawn_mutations</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drawn_mutations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">drawn_mutations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">drawn_mutations</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="n">printsc</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">script_file</span><span class="p">)</span>

    <span class="c1"># Header</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;/*&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot; * stdpopsim &quot;</span> <span class="o">+</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot; *&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot; * Demographic model: &quot;</span> <span class="o">+</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s2">&quot; * &quot;</span>
        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> * &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">citation</span> <span class="ow">in</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">citations</span><span class="p">:</span>
        <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot; * &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">citation</span><span class="p">))</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot; */&quot;</span><span class="p">)</span>

    <span class="n">recomb_rates</span><span class="p">,</span> <span class="n">recomb_ends</span> <span class="o">=</span> <span class="n">msprime_rm_to_slim_rm</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">recombination_map</span><span class="p">)</span>
    <span class="n">indent</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
    <span class="n">recomb_rates_str</span> <span class="o">=</span> <span class="n">slim_array_string</span><span class="p">(</span><span class="n">recomb_rates</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>
    <span class="n">recomb_ends_str</span> <span class="o">=</span> <span class="n">slim_array_string</span><span class="p">(</span><span class="n">recomb_ends</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>

    <span class="n">pop_names_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="n">pop_names</span><span class="p">))</span>

    <span class="n">printsc</span><span class="p">(</span>
        <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="n">_slim_upper</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
            <span class="n">scaling_factor</span><span class="o">=</span><span class="n">scaling_factor</span><span class="p">,</span>
            <span class="n">burn_in</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">burn_in</span><span class="p">),</span>
            <span class="n">recombination_rates</span><span class="o">=</span><span class="n">recomb_rates_str</span><span class="p">,</span>
            <span class="n">recombination_ends</span><span class="o">=</span><span class="n">recomb_ends_str</span><span class="p">,</span>
            <span class="n">generation_time</span><span class="o">=</span><span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">,</span>
            <span class="n">trees_file</span><span class="o">=</span><span class="n">_escape_eidos</span><span class="p">(</span><span class="n">trees_file</span><span class="p">),</span>
            <span class="n">pop_names</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;c(</span><span class="si">{</span><span class="n">pop_names_str</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">matrix2str</span><span class="p">(</span>
        <span class="n">matrix</span><span class="p">,</span> <span class="n">row_comments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col_comment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an Eidos representation of the matrix as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">row_comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_comments</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;c()&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;array(c(</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">col_comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot;// &quot;</span> <span class="o">+</span> <span class="n">col_comment</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]])))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row_comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; // &quot;</span> <span class="o">+</span> <span class="n">row_comments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">indent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;), c(</span><span class="si">{</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">))&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># Genomic element types.</span>
    <span class="n">mutation_callbacks</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dfe_mtypes</span> <span class="o">=</span> <span class="n">_dfe_to_mtypes</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ints</span> <span class="ow">in</span> <span class="n">_enum_dfe_and_intervals</span><span class="p">(</span><span class="n">contig</span><span class="p">):</span>
        <span class="c1"># Mutation types and proportions.</span>
        <span class="n">mut_type_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mut_props_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfe_mtypes</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">mutation_types</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mt_index</span><span class="p">,</span> <span class="p">(</span><span class="n">mid_list</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfe_mtypes</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">Q_scaled_index</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">distrib_args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">distribution_args</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">Q_scaled_index</span><span class="p">:</span>
                    <span class="n">distrib_args</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">Q_scaled_index</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Q * &quot;</span> <span class="o">+</span> <span class="n">distrib_args</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">Q_scaled_index</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                    <span class="p">)</span>
                <span class="n">distrib_args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">distrib_args</span><span class="p">)</span>
            <span class="c1"># dealing with distributions given by &quot;s&quot; Eidos script,</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">distrib_args</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1">&quot;&#39;</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">distribution_args</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">mt</span><span class="o">.</span><span class="n">dominance_coeff_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">h_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">dominance_coeff</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this first value will apply only to mutations that are never kept,</span>
                <span class="c1"># and so has no effect</span>
                <span class="n">h_list</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]</span>
                <span class="n">h_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">dominance_coeff_list</span><span class="p">)</span>
                <span class="c1"># record here what we&#39;ll need to set up the callbacks in script</span>
                <span class="n">mutation_callbacks</span><span class="p">[</span><span class="n">mid_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;dominance_coeff_breaks&quot;</span><span class="p">:</span> <span class="n">mt</span><span class="o">.</span><span class="n">dominance_coeff_breaks</span><span class="p">,</span>
                    <span class="s2">&quot;mutation_types&quot;</span><span class="p">:</span> <span class="n">mid_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="p">}</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mid_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_list</span><span class="p">)</span>
            <span class="n">first_mt</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">mid</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mid_list</span><span class="p">,</span> <span class="n">h_list</span><span class="p">):</span>
                <span class="c1"># We will assign a proportion of 0.0 to mutation types that are neutral</span>
                <span class="c1"># unless all the mutation types in a DFE are neutral. In such case,</span>
                <span class="c1"># SLiM would not allow all mutation types in a genomic element type to</span>
                <span class="c1"># have 0.0 proportion. And the proportions in SLiM won&#39;t matter anyway,</span>
                <span class="c1"># because all the intervals in this fully neutral DFE will have 0.0</span>
                <span class="c1"># mutation rate anyway.</span>
                <span class="c1"># Furthermore, for mutation types with a discretized h-s relationship,</span>
                <span class="c1"># we only mutate to the first assigned mutation type, and remaining ones</span>
                <span class="c1"># are produced by a mutation callback.</span>
                <span class="n">mut_type_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span>
                <span class="n">use_prop</span> <span class="o">=</span> <span class="n">first_mt</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="n">mt</span><span class="o">.</span><span class="n">is_neutral</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">is_neutral</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">proportions</span><span class="p">[</span><span class="n">mt_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">use_prop</span> <span class="k">else</span> <span class="mf">0.0</span>
                <span class="n">mut_props_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">printsc</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;    initializeMutationType(</span><span class="si">{</span><span class="n">mid</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">mt</span><span class="o">.</span><span class="n">distribution_type</span><span class="si">}</span><span class="s1">&quot;, </span><span class="si">{</span><span class="n">distrib_args</span><span class="si">}</span><span class="s1">);&#39;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="o">.</span><span class="n">convert_to_substitution</span><span class="p">:</span>
                    <span class="c1"># T is the default for WF simulations.</span>
                    <span class="n">printsc</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    m</span><span class="si">{</span><span class="n">mid</span><span class="si">}</span><span class="s2">.convertToSubstitution = F;&quot;</span><span class="p">)</span>
                <span class="c1"># TODO: when msprime.SLiMMutationModel supports stacking policy,</span>
                <span class="c1"># set policy such that there&#39;s at most a single mutation per-site</span>
                <span class="c1"># and individual</span>
                <span class="c1"># printsc(f&quot;    mt{mid}.mutationStackGroup = 0;&quot;)</span>
                <span class="c1"># printsc(f&quot;    mt{mid}.mutationStackPolicy = &#39;l&#39;;&quot;)</span>
                <span class="n">first_mt</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">mut_types</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">mut_type_list</span><span class="p">])</span>
        <span class="n">mut_props</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">mut_props_list</span><span class="p">))</span>
        <span class="n">printsc</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;    initializeGenomicElementType(</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">, c(</span><span class="si">{</span><span class="n">mut_types</span><span class="si">}</span><span class="s2">), c(</span><span class="si">{</span><span class="n">mut_props</span><span class="si">}</span><span class="s2">));&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_neutral</span><span class="p">:</span>
            <span class="n">printsc</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;    // Note: genomic element type </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> is entirely neutral,&quot;</span>
                <span class="s2">&quot; so will not be simulated by SLiM.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">ints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">element_starts</span> <span class="o">=</span> <span class="n">slim_array_string</span><span class="p">(</span><span class="n">ints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">indent</span><span class="p">)</span>
            <span class="c1"># stdpopsim intervals are 0-based left inclusive, right exclusive, but</span>
            <span class="c1"># SLiM intervals are right inclusive</span>
            <span class="n">element_ends</span> <span class="o">=</span> <span class="n">slim_array_string</span><span class="p">(</span><span class="n">ints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>
            <span class="n">printsc</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;    initializeGenomicElement(</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">element_starts</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">element_ends</span><span class="si">}</span><span class="s2">);&quot;</span>
            <span class="p">)</span>
    <span class="c1"># Mutation rate map.</span>
    <span class="n">mut_breaks</span> <span class="o">=</span> <span class="n">slim_array_string</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">slim_rate_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">indent</span><span class="p">)</span>
    <span class="n">mut_rates</span> <span class="o">=</span> <span class="n">slim_array_string</span><span class="p">(</span><span class="n">slim_rate_map</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indent</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    initializeMutationRate(Q*</span><span class="si">{</span><span class="n">mut_rates</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">mut_breaks</span><span class="si">}</span><span class="s2">);&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Epoch times.</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Time of epoch boundaries, in years before present.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // The first epoch spans from INF to _T[0].&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s1">&#39;    defineConstant(&quot;_T&quot;, c(</span><span class="si">{}</span><span class="s1">));&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">))))</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Population sizes.</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Population sizes at the beginning of each epoch&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // (will be rounded).&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s2">&quot;    _N = &quot;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">row_comments</span><span class="o">=</span><span class="n">pop_names</span><span class="p">,</span> <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;INF:_T[0], _T[0]:_T[1], etc.&quot;</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;;&quot;</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="n">printsc</span><span class="p">(</span><span class="s1">&#39;    defineConstant(&quot;num_epochs&quot;, length(_T));&#39;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s1">&#39;    defineConstant(&quot;num_populations&quot;, ncol(_N));&#39;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Growth rates.</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Population growth rates for each epoch.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;growth_rates&quot;, &#39;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span>
            <span class="n">growth_rates</span><span class="p">,</span>
            <span class="n">row_comments</span><span class="o">=</span><span class="n">pop_names</span><span class="p">,</span>
            <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;INF:_T[0], _T[0]:_T[1], etc.&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;num_epochs&quot;</span><span class="p">,</span> <span class="s2">&quot;num_populations&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;);&quot;</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    no_migration = rep(0, num_populations*num_populations);&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Migration rates.</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Migration rates for each epoch.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Migrations involving a population with size=0 are ignored.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // XXX: document what the rows &amp; cols correspond to.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s1">&#39;    defineConstant(&quot;migration_matrices&quot;, array(c(&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">migration_matrices</span><span class="p">)):</span>
        <span class="n">epoch_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;INF:_T[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;_T[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]:_T[</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="n">printsc</span><span class="p">()</span>
        <span class="n">printsc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot;// &quot;</span> <span class="o">+</span> <span class="n">epoch_str</span><span class="p">)</span>

        <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">migration_matrices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">migration_matrices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">printsc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot;no_migration&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">printsc</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
                <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span>
                    <span class="n">migration_matrices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">indent</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span>
                    <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;num_populations&quot;</span><span class="p">,</span> <span class="s2">&quot;num_populations&quot;</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>
    <span class="n">printsc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot;), c(num_populations, num_populations, num_epochs)));&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Population splits.</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Population splits, one row for each event.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;subpopulation_splits&quot;, &#39;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span><span class="n">subpopulation_splits</span><span class="p">,</span> <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;time, newpop, size, oldpop&quot;</span><span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;);&quot;</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Admixture pulses.</span>
    <span class="c1"># Output _T[...] variable rather than an index.</span>
    <span class="n">admixture_pulses</span> <span class="o">=</span> <span class="p">[(</span><span class="sa">f</span><span class="s2">&quot;_T[</span><span class="si">{</span><span class="n">ap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">ap</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">admixture_pulses</span><span class="p">]</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Admixture pulses, one row for each pulse.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;admixture_pulses&quot;, &#39;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span><span class="n">admixture_pulses</span><span class="p">,</span> <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;time, dest, source, rate&quot;</span><span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;);&quot;</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Drawn mutations.</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Drawn mutations, one row for each mutation.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;drawn_mutations&quot;, &#39;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span>
            <span class="n">drawn_mutations</span><span class="p">,</span>
            <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;time, mut_type, pop_id, genomic_coordinate, save&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;);&quot;</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Fitness callbacks.</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Fitness callbacks, one row for each callback.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;fitness_callbacks&quot;, &#39;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span>
            <span class="n">fitness_callbacks</span><span class="p">,</span>
            <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;start_time, end_time, mut_type, pop_id, &quot;</span>
            <span class="s2">&quot;selection_coeff, dominance_coeff&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;);&quot;</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Mutation callbacks.</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s2">&quot;    // Mutations callbacks for h-s relationships, &quot;</span>
        <span class="s2">&quot;one variable for each callback.&quot;</span>
    <span class="p">)</span>
    <span class="n">mut_types_with_callbacks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mutation_callbacks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;mut_types_with_callbacks&quot;, c(&#39;</span>
        <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">mut_types_with_callbacks</span><span class="p">))</span>
        <span class="o">+</span> <span class="s2">&quot;));&quot;</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">mut_types_with_callbacks</span><span class="p">:</span>
        <span class="n">printsc</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;    defineConstant(&quot;dominance_coeff_types_</span><span class="si">{</span><span class="n">mt</span><span class="si">}</span><span class="s1">&quot;, c(&#39;</span>
            <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">mutation_callbacks</span><span class="p">[</span><span class="n">mt</span><span class="p">][</span><span class="s2">&quot;mutation_types&quot;</span><span class="p">]))</span>
            <span class="o">+</span> <span class="s2">&quot;));&quot;</span>
        <span class="p">)</span>

        <span class="n">printsc</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;    defineConstant(&quot;dominance_coeff_breaks_</span><span class="si">{</span><span class="n">mt</span><span class="si">}</span><span class="s1">&quot;, c(-INF, &#39;</span>
            <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">mutation_callbacks</span><span class="p">[</span><span class="n">mt</span><span class="p">][</span><span class="s2">&quot;dominance_coeff_breaks&quot;</span><span class="p">]))</span>
            <span class="o">+</span> <span class="s2">&quot;, INF));&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Allele frequency conditioning</span>
    <span class="n">op_types</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s1">&quot;&#39;</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">ConditionOnAlleleFrequency</span><span class="o">.</span><span class="n">op_types</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    defineConstant(&quot;op_types&quot;, c(</span><span class="si">{</span><span class="n">op_types</span><span class="si">}</span><span class="s1">));&#39;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // Allele frequency conditioning, one row for each.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;condition_on_allele_frequency&quot;, &#39;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span>
            <span class="n">condition_on_allele_frequency</span><span class="p">,</span>
            <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;start_time, end_time, mut_type, pop_id, &quot;</span>
            <span class="s2">&quot;op, allele_frequency&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;);&quot;</span>
    <span class="p">)</span>
    <span class="n">printsc</span><span class="p">()</span>

    <span class="c1"># Sampling episodes.</span>
    <span class="n">sampling_episodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">sample_set</span><span class="o">.</span><span class="n">population</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">time</span>
        <span class="n">time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># SLiM can only sample individuals, which we assume are diploid.</span>
            <span class="n">n_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gen</span> <span class="o">=</span> <span class="n">time</span> <span class="o">/</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">generation_time</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="n">stdpopsim</span><span class="o">.</span><span class="n">SLiMOddSampleWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;SLiM simulates diploid individuals, so </span><span class="si">{</span><span class="n">n_inds</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;individuals will be sampled for the </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> haploids &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;requested from population </span><span class="si">{</span><span class="n">pop</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> at time </span><span class="si">{</span><span class="n">gen</span><span class="si">}</span><span class="s2">. &quot;</span>
                        <span class="s2">&quot;See #464.&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">n_inds</span> <span class="o">=</span> <span class="n">count</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Sample ploidy other than 1 or 2 is not currently supported in &quot;</span>
                <span class="s2">&quot;the SLiM engine.&quot;</span>
            <span class="p">)</span>
        <span class="n">sampling_episodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pop</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">n_inds</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span>

    <span class="n">printsc</span><span class="p">(</span><span class="s2">&quot;    // One row for each sampling episode.&quot;</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span>
        <span class="s1">&#39;    defineConstant(&quot;sampling_episodes&quot;, &#39;</span>
        <span class="o">+</span> <span class="n">matrix2str</span><span class="p">(</span><span class="n">sampling_episodes</span><span class="p">,</span> <span class="n">col_comment</span><span class="o">=</span><span class="s2">&quot;pop, n_inds, time&quot;</span><span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;);&quot;</span>
    <span class="p">)</span>

    <span class="n">printsc</span><span class="p">(</span><span class="n">_slim_lower</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="n">_slim_functions</span><span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="n">_slim_main</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">printsc</span><span class="p">(</span>
            <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="n">_slim_logfile</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">logfile</span><span class="o">=</span><span class="n">_escape_eidos</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">logfile</span><span class="p">)),</span>
                <span class="n">loginterval</span><span class="o">=</span><span class="n">logfile_interval</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">printsc</span><span class="p">(</span><span class="n">_slim_debug_output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SLiMException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="_SLiMEngine">
<a class="viewcode-back" href="../../api.html#stdpopsim.slim_engine._SLiMEngine">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">_SLiMEngine</span><span class="p">(</span><span class="n">stdpopsim</span><span class="o">.</span><span class="n">Engine</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="s2">&quot;slim&quot;</span>  <span class="c1">#:</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;SLiM forward-time Wright-Fisher simulator&quot;</span>  <span class="c1">#:</span>
    <span class="n">citations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">stdpopsim</span><span class="o">.</span><span class="n">Citation</span><span class="p">(</span>
            <span class="n">doi</span><span class="o">=</span><span class="s2">&quot;https://doi.org/10.1111/1755-0998.12968&quot;</span><span class="p">,</span>
            <span class="n">year</span><span class="o">=</span><span class="mi">2019</span><span class="p">,</span>
            <span class="n">author</span><span class="o">=</span><span class="s2">&quot;Haller et al.&quot;</span><span class="p">,</span>
            <span class="n">reasons</span><span class="o">=</span><span class="p">{</span><span class="n">stdpopsim</span><span class="o">.</span><span class="n">CiteReason</span><span class="o">.</span><span class="n">ENGINE</span><span class="p">},</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">slim_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SLIM&quot;</span><span class="p">,</span> <span class="s2">&quot;slim&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_version</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slim_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">slim_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slim_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slim_path</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="n">slim_path</span><span class="p">,</span> <span class="s2">&quot;-v&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_min_version</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_required_version</span><span class="p">,</span> <span class="n">slim_path</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">version_split</span><span class="p">(</span><span class="n">version</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">version</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)]</span>

        <span class="n">current_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_version</span><span class="p">(</span><span class="n">slim_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">version_split</span><span class="p">(</span><span class="n">current_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version_split</span><span class="p">(</span><span class="n">min_required_version</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Minimum supported SLiM version is </span><span class="si">{</span><span class="n">min_required_version</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but only found version </span><span class="si">{</span><span class="n">current_version</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="_SLiMEngine.simulate">
<a class="viewcode-back" href="../../api.html#stdpopsim.slim_engine._SLiMEngine.simulate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">demographic_model</span><span class="p">,</span>
        <span class="n">contig</span><span class="p">,</span>
        <span class="n">samples</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extended_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">slim_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">slim_script</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">slim_burn_in</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="n">dry_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbosity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">logfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">logfile_interval</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">keep_mutation_ids_as_alleles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_recap_and_rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the demographic model using SLiM.</span>
<span class="sd">        See :meth:`.Engine.simulate()` for definitions of the</span>
<span class="sd">        ``demographic_model``, ``contig``, and ``samples`` parameters.</span>

<span class="sd">        :param seed: The seed for the random number generator.</span>
<span class="sd">        :type seed: int</span>
<span class="sd">        :param extended_events: A list of :class:`ExtendedEvents` to be</span>
<span class="sd">            passed to SLiM, e.g. produced by :func:`selective_sweep()`.</span>
<span class="sd">        :type extended_events: list</span>
<span class="sd">        :param slim_path: The full path to the slim executable, or the name of</span>
<span class="sd">            a command in the current PATH.</span>
<span class="sd">        :type slim_path: str</span>
<span class="sd">        :param slim_script: If true, the simulation will not be executed.</span>
<span class="sd">            Instead the generated SLiM script will be printed to stdout.</span>
<span class="sd">        :type slim_script: bool</span>
<span class="sd">        :param slim_scaling_factor: Rescale model parameters by the given value,</span>
<span class="sd">            to speed up simulation. Population sizes and generation times are</span>
<span class="sd">            divided by this factor, whereas the mutation rate, recombination</span>
<span class="sd">            rate, and growth rates are multiplied by the factor.</span>
<span class="sd">            See SLiM manual: `5.5 Rescaling population sizes to improve</span>
<span class="sd">            simulation performance.`</span>
<span class="sd">        :type slim_scaling_factor: float</span>
<span class="sd">        :param slim_burn_in: Length of the burn-in phase, in units of N</span>
<span class="sd">            generations.</span>
<span class="sd">        :type slim_burn_in: float</span>
<span class="sd">        :param dry_run: If True, run the setup and then end the simulation.</span>
<span class="sd">        :type dry_run: bool</span>
<span class="sd">        :param logfile: Name of file to write a log of summary statistics</span>
<span class="sd">            (currently, only mean and SD of fitness values per population).</span>
<span class="sd">            Defaults to None, meaning &quot;do not log&quot;.</span>
<span class="sd">        :param logfile_interval: How often to write to the log file, in generations.</span>
<span class="sd">        :param keep_mutation_ids_as_alleles: If true, alleles will be coded by integer</span>
<span class="sd">            mutation ids (assigned by SLiM) rather than by randomly-generated</span>
<span class="sd">            nucleotides.</span>
<span class="sd">        :type keep_mutation_ids_as_alleles: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">slim_scaling_factor</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;slim_scaling_factor must be positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slim_burn_in</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;slim_burn_in must be non-negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contig</span><span class="o">.</span><span class="n">dfe_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SLiM requires at least one DFE.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">slim_scaling_factor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">stdpopsim</span><span class="o">.</span><span class="n">SLiMScalingFactorWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;You&#39;re using a scaling factor (</span><span class="si">{</span><span class="n">slim_scaling_factor</span><span class="si">}</span><span class="s2">). &quot;</span>
                    <span class="s2">&quot;This should give similar results for many situations, &quot;</span>
                    <span class="s2">&quot;but is not equivalent, especially in the presence of selection. &quot;</span>
                    <span class="s2">&quot;When using rescaling, you should be careful---do checks and &quot;</span>
                    <span class="s2">&quot;compare results across different values of the scaling factor.&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># handle deprecated samples=[msprime.SampleSet] input</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">get_sample_sets</span><span class="p">(</span>
                <span class="n">samples</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="n">contig</span><span class="o">.</span><span class="n">ploidy</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">]):</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Samples must be a dict of the form {population_name:num_samples}.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># figuring out mutations in SLiM and neutral mutations to be added</span>
        <span class="c1"># by msprime later</span>
        <span class="n">slim_rate_map</span> <span class="o">=</span> <span class="n">get_slim_mutation_rate_map</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_mutation_rate_mismatch</span><span class="p">(</span><span class="n">contig</span><span class="p">,</span> <span class="n">demographic_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_recombination_rate_mismatch</span><span class="p">(</span><span class="n">contig</span><span class="p">,</span> <span class="n">demographic_model</span><span class="p">)</span>

        <span class="n">run_slim</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">slim_script</span>

        <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_slim_tempdir</span><span class="p">():</span>
            <span class="n">tempdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">(</span>
                <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;stdpopsim_&quot;</span><span class="p">,</span> <span class="n">ignore_cleanup_errors</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">ts_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">.trees&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">run_slim</span><span class="p">:</span>
                <span class="n">script_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">.slim&quot;</span>
                <span class="p">)</span>
                <span class="n">script_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">script_filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">script_filename</span> <span class="o">=</span> <span class="s2">&quot;stdout&quot;</span>
                <span class="n">script_file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
            <span class="k">yield</span> <span class="n">script_file</span><span class="p">,</span> <span class="n">script_filename</span><span class="p">,</span> <span class="n">ts_filename</span>
            <span class="k">if</span> <span class="n">run_slim</span><span class="p">:</span>
                <span class="n">script_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">tempdir</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">_slim_tempdir</span><span class="p">()</span> <span class="k">as</span> <span class="n">st</span><span class="p">:</span>
            <span class="n">script_file</span><span class="p">,</span> <span class="n">script_filename</span><span class="p">,</span> <span class="n">ts_filename</span> <span class="o">=</span> <span class="n">st</span>

            <span class="n">recap_epoch</span> <span class="o">=</span> <span class="n">slim_makescript</span><span class="p">(</span>
                <span class="n">script_file</span><span class="p">,</span>
                <span class="n">ts_filename</span><span class="p">,</span>
                <span class="n">demographic_model</span><span class="p">,</span>
                <span class="n">contig</span><span class="p">,</span>
                <span class="n">sample_sets</span><span class="p">,</span>
                <span class="n">extended_events</span><span class="p">,</span>
                <span class="n">slim_scaling_factor</span><span class="p">,</span>
                <span class="n">slim_burn_in</span><span class="p">,</span>
                <span class="n">slim_rate_map</span><span class="p">,</span>
                <span class="n">logfile</span><span class="o">=</span><span class="n">logfile</span><span class="p">,</span>
                <span class="n">logfile_interval</span><span class="o">=</span><span class="n">logfile_interval</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">script_file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">run_slim</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_run_slim</span><span class="p">(</span>
                <span class="n">script_filename</span><span class="p">,</span>
                <span class="n">slim_path</span><span class="o">=</span><span class="n">slim_path</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                <span class="n">dry_run</span><span class="o">=</span><span class="n">dry_run</span><span class="p">,</span>
                <span class="n">verbosity</span><span class="o">=</span><span class="n">verbosity</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">dry_run</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">ts</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ts_filename</span><span class="p">)</span>

            <span class="n">ts</span> <span class="o">=</span> <span class="n">_add_dfes_to_metadata</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">contig</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_recap_and_rescale</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recap_and_rescale</span><span class="p">(</span>
                    <span class="n">ts</span><span class="p">,</span>
                    <span class="n">seed</span><span class="p">,</span>
                    <span class="n">recap_epoch</span><span class="p">,</span>
                    <span class="n">contig</span><span class="p">,</span>
                    <span class="n">slim_scaling_factor</span><span class="p">,</span>
                    <span class="n">keep_mutation_ids_as_alleles</span><span class="p">,</span>
                    <span class="n">extended_events</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">contig</span><span class="o">.</span><span class="n">inclusion_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mask_tree_sequence</span><span class="p">(</span>
                    <span class="n">ts</span><span class="p">,</span> <span class="n">contig</span><span class="o">.</span><span class="n">inclusion_mask</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">contig</span><span class="o">.</span><span class="n">exclusion_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mask_tree_sequence</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">contig</span><span class="o">.</span><span class="n">exclusion_mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ts</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_run_slim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">,</span> <span class="n">slim_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run SLiM.</span>

<span class="sd">        We capture the output using Popen&#39;s line-oriented text buffering</span>
<span class="sd">        (bufsize=1, universal_newlines=True) and redirect all messages to</span>
<span class="sd">        Python&#39;s logging module.</span>
<span class="sd">        By convention, messages from SLiM prefixed with &quot;ERROR: &quot; or</span>
<span class="sd">        &quot;WARNING: &quot; are treated as ERROR or WARN loglevels respectively.</span>
<span class="sd">        All other output on stdout is given the DEBUG loglevel.</span>
<span class="sd">        ERROR messages will raise a SLiMException here too, because</span>
<span class="sd">        they are always generated by the `stop()` eidos function which</span>
<span class="sd">        makes SLiM exit with a non-zero return code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">slim_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slim_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slim_path</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_min_version</span><span class="p">(</span><span class="s2">&quot;4.0&quot;</span><span class="p">,</span> <span class="n">slim_path</span><span class="p">)</span>

        <span class="n">slim_cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">slim_path</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slim_cmd</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">seed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="n">slim_cmd</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;-d&quot;</span><span class="p">,</span> <span class="s2">&quot;dry_run=T&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbosity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slim_cmd</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;-d&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;verbosity=</span><span class="si">{</span><span class="n">verbosity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="n">slim_cmd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span>
            <span class="n">slim_cmd</span><span class="p">,</span>
            <span class="n">bufsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">proc</span><span class="p">:</span>
            <span class="n">procout</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># we get procout == None with the patching of suprocess.Popen</span>
                <span class="c1"># that we do in test_slim_engine.py::TestCLI::test_dry_run</span>
                <span class="n">outs</span><span class="p">,</span> <span class="n">errs</span> <span class="o">=</span> <span class="n">procout</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="n">stdpopsim</span><span class="o">.</span><span class="n">UnspecifiedSLiMWarning</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot get output from SLiM &quot;</span> <span class="s2">&quot;for unknown reasons.&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">outs</span><span class="p">,</span> <span class="n">errs</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">outs</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;WARNING: &quot;</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="n">stdpopsim</span><span class="o">.</span><span class="n">UnspecifiedSLiMWarning</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;WARNING: &quot;</span><span class="p">)</span> <span class="p">:])</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># filter `dbg` function calls that generate output</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;dbg(self.source); &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">errs</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ERROR: &quot;</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;ERROR: &quot;</span><span class="p">)</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SLiMException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slim_path</span><span class="si">}</span><span class="s2"> exited with code </span><span class="si">{</span><span class="n">proc</span><span class="o">.</span><span class="n">returncode</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="n">errs</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_simplify_remembered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all samples except those individuals that were explicity</span>
<span class="sd">        sampled in SLiM with sim.treeSeqRememberIndividuals().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
            <span class="n">i</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">individuals</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">pyslim</span><span class="o">.</span><span class="n">INDIVIDUAL_REMEMBERED</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">filter_populations</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_recap_and_rescale</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ts</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">,</span>
        <span class="n">recap_epoch</span><span class="p">,</span>
        <span class="n">contig</span><span class="p">,</span>
        <span class="n">slim_scaling_factor</span><span class="p">,</span>
        <span class="n">keep_mutation_ids_as_alleles</span><span class="p">,</span>
        <span class="n">extended_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply post-SLiM transformations to ``ts``. This rescales node times,</span>
<span class="sd">        does recapitation, simplification, adds neutral mutations, converts</span>
<span class="sd">        alleles to nucleotides, and rebuilds the individual table for haploids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Times come from SLiM generation numbers, which may have been</span>
        <span class="c1"># divided by a scaling factor for computational tractability.</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">migrations</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">):</span>
            <span class="n">table</span><span class="o">.</span><span class="n">time</span> <span class="o">*=</span> <span class="n">slim_scaling_factor</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">metadata</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;SLiM&quot;</span><span class="p">][</span><span class="s2">&quot;tick&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">slim_scaling_factor</span>
        <span class="c1"># If a single site DFE is referenced by an extended event, mark the DFE</span>
        <span class="c1"># as non-neutral so that mutations aren&#39;t simulated over it.</span>
        <span class="k">if</span> <span class="n">extended_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">single_sites</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">extended_events</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="s2">&quot;single_site_id&quot;</span><span class="p">)</span>
                <span class="n">single_sites</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ee</span><span class="o">.</span><span class="n">single_site_id</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dfe</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;stdpopsim&quot;</span><span class="p">][</span><span class="s2">&quot;DFEs&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">single_sites</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;mutation_types&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;mutation_types&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;is_neutral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Finding what slim id to use in recap DFE</span>
        <span class="n">max_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">dfe</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;stdpopsim&quot;</span><span class="p">][</span><span class="s2">&quot;DFEs&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;mutation_types&quot;</span><span class="p">]:</span>
                <span class="n">max_id</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">mt</span><span class="p">[</span><span class="s2">&quot;slim_mutation_type_id&quot;</span><span class="p">]),</span> <span class="n">max_id</span><span class="p">)</span>
        <span class="n">recap_dfe</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;recapitation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;DFE used in recapitation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long_description&quot;</span><span class="p">:</span> <span class="s2">&quot;neutral mutations added with msprime.sim_mutations &quot;</span>
            <span class="s2">&quot;to the recapited portion of the tree sequence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mutation_types&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;dominance_coeff&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
                    <span class="s2">&quot;distribution_type&quot;</span><span class="p">:</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;distribution_args&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;convert_to_substitution&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="s2">&quot;Q_scaled_index&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;slim_mutation_type_id&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="n">max_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;is_neutral&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">],</span>
            <span class="s2">&quot;proportions&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
            <span class="s2">&quot;citations&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;intervals&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">]],</span>
        <span class="p">}</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;stdpopsim&quot;</span><span class="p">][</span><span class="s2">&quot;DFEs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recap_dfe</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">)</span>
        <span class="n">population_configurations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span>
                <span class="n">initial_size</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">start_size</span><span class="p">,</span>
                <span class="n">growth_rate</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">growth_rate</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">pop</span><span class="o">.</span><span class="n">name</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">recap_epoch</span><span class="o">.</span><span class="n">populations</span>
        <span class="p">]</span>

        <span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">from_old_style</span><span class="p">(</span>
            <span class="n">population_configurations</span><span class="o">=</span><span class="n">population_configurations</span><span class="p">,</span>
            <span class="n">migration_matrix</span><span class="o">=</span><span class="n">recap_epoch</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># `recap_epoch` contains population sizes from the demographic model,</span>
        <span class="c1"># that are the number of individuals regardless of ploidy. Thus,</span>
        <span class="c1"># ploidy must be set here, as is done in `_MsprimeEngine.simulate`</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
            <span class="n">initial_state</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span>
            <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
            <span class="n">recombination_rate</span><span class="o">=</span><span class="n">contig</span><span class="o">.</span><span class="n">recombination_map</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="n">contig</span><span class="o">.</span><span class="n">ploidy</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">s0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_remembered</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

        <span class="c1"># Adding neutral mutations to simulation and recapitation periods</span>
        <span class="n">breaks</span><span class="p">,</span> <span class="n">dfe_labels</span> <span class="o">=</span> <span class="n">contig</span><span class="o">.</span><span class="n">dfe_breakpoints</span><span class="p">()</span>  <span class="c1"># beware -1 labels</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dfe</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;stdpopsim&quot;</span><span class="p">][</span><span class="s2">&quot;DFEs&quot;</span><span class="p">]):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;proportions&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;mutation_types&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">mt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;proportions&quot;</span><span class="p">],</span> <span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;mutation_types&quot;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">mt</span><span class="p">[</span><span class="s2">&quot;is_neutral&quot;</span><span class="p">]:</span>
                    <span class="n">mut_seed</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">)</span>
                    <span class="c1"># Figuring out SLiM mutation id metadata</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">_get_next_id</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
                        <span class="n">max_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">for</span> <span class="n">mut</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">mutations</span><span class="p">():</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">mut</span><span class="o">.</span><span class="n">derived_state</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                                <span class="n">max_id</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">max_id</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">_get_msp_rate_map</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">is_this_dfe</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
                        <span class="n">rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">is_this_dfe</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                        <span class="n">rates</span><span class="p">[</span><span class="n">is_this_dfe</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate</span>
                        <span class="k">return</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">breaks</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">rates</span><span class="p">)</span>

                    <span class="c1"># Use msprime.SLiMMutationModel rather than msprime.JC69</span>
                    <span class="c1"># for neutral DFEs.  This ensures that there will be a</span>
                    <span class="c1"># &#39;selection_coef&#39; key in the mutation metadata (so the</span>
                    <span class="c1"># mutation metadata structure will be consistent across the</span>
                    <span class="c1"># tree sequence).</span>
                    <span class="c1"># TODO: set stacking policy to &quot;l&quot; when supported</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SLiMMutationModel</span><span class="p">(</span>
                        <span class="nb">type</span><span class="o">=</span><span class="n">mt</span><span class="p">[</span><span class="s2">&quot;slim_mutation_type_id&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">next_id</span><span class="o">=</span><span class="n">_get_next_id</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span>
                    <span class="p">)</span>

                    <span class="c1"># Add mutations to recapitated part of trees.</span>
                    <span class="n">start_time</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">dfe</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;recapitation&quot;</span><span class="p">:</span>
                        <span class="n">start_time</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;SLiM&quot;</span><span class="p">][</span><span class="s2">&quot;tick&quot;</span><span class="p">]</span>
                        <span class="n">msp_rate_map</span> <span class="o">=</span> <span class="n">_get_msp_rate_map</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">contig</span><span class="o">.</span><span class="n">length</span><span class="p">]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">]),</span>
                            <span class="n">contig</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">msp_rate_map</span> <span class="o">=</span> <span class="n">_get_msp_rate_map</span><span class="p">(</span>
                            <span class="n">breaks</span><span class="p">,</span> <span class="n">dfe_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="n">prop</span> <span class="o">*</span> <span class="n">contig</span><span class="o">.</span><span class="n">mutation_rate</span>
                        <span class="p">)</span>
                        <span class="n">end_time</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;SLiM&quot;</span><span class="p">][</span><span class="s2">&quot;tick&quot;</span><span class="p">]</span>
                    <span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_mutations</span><span class="p">(</span>
                        <span class="n">ts</span><span class="p">,</span>
                        <span class="n">rate</span><span class="o">=</span><span class="n">msp_rate_map</span><span class="p">,</span>
                        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
                        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
                        <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">random_seed</span><span class="o">=</span><span class="n">mut_seed</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_mutation_ids_as_alleles</span><span class="p">:</span>
            <span class="n">nuc_seed</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">pyslim</span><span class="o">.</span><span class="n">convert_alleles</span><span class="p">(</span>
                <span class="n">pyslim</span><span class="o">.</span><span class="n">generate_nucleotides</span><span class="p">(</span>
                    <span class="n">ts</span><span class="p">,</span>
                    <span class="n">seed</span><span class="o">=</span><span class="n">nuc_seed</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># If haploid, rebuild individual table so each sample is an individual</span>
        <span class="k">if</span> <span class="n">contig</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">stdpopsim</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">haploidize_individuals</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ts</span>

<div class="viewcode-block" id="_SLiMEngine.recap_and_rescale">
<a class="viewcode-back" href="../../api.html#stdpopsim.slim_engine._SLiMEngine.recap_and_rescale">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">recap_and_rescale</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ts</span><span class="p">,</span>
        <span class="n">demographic_model</span><span class="p">,</span>
        <span class="n">contig</span><span class="p">,</span>
        <span class="n">samples</span><span class="p">,</span>
        <span class="n">extended_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">slim_scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_mutation_ids_as_alleles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply post-SLiM transformations to ``ts``. This rescales node times,</span>
<span class="sd">        does recapitation, simplification, and adds neutral mutations.</span>

<span class="sd">        If the SLiM engine was used to output a SLiM script, and the script was</span>
<span class="sd">        run outside of stdpopsim, this function can be used to transform the</span>
<span class="sd">        SLiM tree sequence following the procedure that would have been used</span>
<span class="sd">        if stdpopsim had run SLiM itself.</span>
<span class="sd">        The parameters after ``ts`` have the same meaning as for :func:`simulate`,</span>
<span class="sd">        and the values for ``demographic_model``, ``contig``, ``samples``,</span>
<span class="sd">        and ``slim_scaling_factor`` should match those that were used to</span>
<span class="sd">        generate the SLiM script with :func:`simulate`.</span>

<span class="sd">        :param ts: The tree sequence output by SLiM.</span>
<span class="sd">        :type ts: :class:`tskit.TreeSequence`</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The :func:`recap_and_rescale` function is provided in the hope that</span>
<span class="sd">            it will be useful. But as we can&#39;t anticipate what changes you&#39;ll</span>
<span class="sd">            make to the SLiM code before using it, the stdpopsim source code</span>
<span class="sd">            should be consulted to determine if the behaviour is appropriate</span>
<span class="sd">            for your case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slim_rate_map</span> <span class="o">=</span> <span class="n">get_slim_mutation_rate_map</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>

        <span class="c1"># handle deprecated samples=[msprime.SampleSet] input</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">demographic_model</span><span class="o">.</span><span class="n">get_sample_sets</span><span class="p">(</span>
                <span class="n">samples</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="n">contig</span><span class="o">.</span><span class="n">ploidy</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">]):</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Samples must be a dict of the form {population_name:num_samples}.&quot;</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">script_file</span><span class="p">:</span>
            <span class="n">recap_epoch</span> <span class="o">=</span> <span class="n">slim_makescript</span><span class="p">(</span>
                <span class="n">script_file</span><span class="p">,</span>
                <span class="s2">&quot;unused.trees&quot;</span><span class="p">,</span>
                <span class="n">demographic_model</span><span class="p">,</span>
                <span class="n">contig</span><span class="p">,</span>
                <span class="n">sample_sets</span><span class="p">,</span>
                <span class="n">extended_events</span><span class="p">,</span>
                <span class="n">slim_scaling_factor</span><span class="p">,</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="n">slim_rate_map</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">_add_dfes_to_metadata</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">contig</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recap_and_rescale</span><span class="p">(</span>
            <span class="n">ts</span><span class="p">,</span>
            <span class="n">seed</span><span class="p">,</span>
            <span class="n">recap_epoch</span><span class="p">,</span>
            <span class="n">contig</span><span class="p">,</span>
            <span class="n">slim_scaling_factor</span><span class="p">,</span>
            <span class="n">keep_mutation_ids_as_alleles</span><span class="p">,</span>
            <span class="n">extended_events</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span></div>
</div>



<span class="n">stdpopsim</span><span class="o">.</span><span class="n">register_engine</span><span class="p">(</span><span class="n">_SLiMEngine</span><span class="p">())</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2025, PopSim Consortium.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
     
    <div class="footer">Version: 0.2 (0.2.1a2.dev85+gb410acf)</div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>